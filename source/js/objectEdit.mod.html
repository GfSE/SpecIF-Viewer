<script type="text/javascript">
/*	ReqIF Server: Object Edit.
	Dependencies: jQuery, knockout, bootstrap
	(C)copyright enso managers gmbh (http://www.enso-managers.de)
	Author: se@enso-managers.de, Berlin
	We appreciate any correction, comment or contribution via e-mail to support@reqif.de  
*/
// ToDo: warn before closing the edit panel once an input has been made.

function ObjectEditVM() {
	"use strict";
	var self = this,
		returnView = null,
		storing = false,
		selectedObject = null,  // with original attribute values
		// The editor options:
		sceditorOpts = {
			plugins: 'xhtml',
			toolbar: "bold,italic,underline,removeformat|bulletlist,orderedlist|table|"+
				"image,email,link,unlink|"+
				"left,center,right,justify|maximize,source",
			style: "./css/jquery.sceditor-1.5.2.default.min.css",
			emoticonsEnabled: false,
			resizeEnabled: false
		};
	self.mode = ko.observable(null);  // mode, may take the values 'update', 'clone', 'new'
	self.eligibleObjTypes = ko.observableArray( [] );    // all object types, for which the user can create new instances
	self.selectedObjType = ko.observable( {id: null} );   // controls which attributes to show when creating a new object
	self.images = ko.observableArray( [] );  // list of images for selecting an image in the wysiwyg editor.
	self.objE = ko.observable( {title:'', attributes: ko.observableArray([])} );   // attributes will be edited here

	// Standard module interface methods:
	self.open = function( cb, md ) {
		if( typeof cb=="function" ) returnView = cb;   // callback
		self.mode( md || 'update' );
		setStyle(
			'div.image-tile { display: inline-block; margin: 4px; width: 120px; }'
		);
		setEditorCmds();  // initialize the wysiwyg-editor for formatted text
	};
	self.clear = function() {
		self.objE( {longName:'', attributes: ko.observableArray([])} );
		self.mode(null);
		self.eligibleObjTypes.removeAll();
//		self.selectedObjType( {id: null} );
		self.images.removeAll();
		selectedObject = null; 
		storing = false
	};
	self.hide = function() {
		projects.busy.set( false )
	};
	self.close = function() {
		self.hide();
		self.clear()
	};
	function returnOnSuccess() {
		self.hide();
		self.clear();
		returnView()
	};
	function handleError(xhr) {
		switch( xhr.status ) {
			case 200:
			case 201:
				return;   
			case 500:
				message.show( "(" + xhr.status + "): " + i18n.ErrInvalidContent, 'danger', CONFIG.messageDisplayTimeLong );
				console.error( xhr.statusText + " (" + xhr.status + "): " + xhr.responseText );
//				self.correct();
				return;
			case 995:  // server request timeout
//				xhr.responseText = 'You may try again once or twice.';
				message.showXhr( xhr, 'warning' );
				console.error( xhr.statusText + " (" + xhr.status + (xhr.responseText?"): "+xhr.responseText:")") );
				return;
			default:
				// This is a sub-module to specs, so use its return method
				self.hide();
				self.clear();
				stdError(xhr,specs.returnToCaller)
		}
	};
	function handleUpdateError(xhr) {
		switch( xhr.status ) {
			case 200:
			case 201:
				return;   // some calls end up in the fail trail, even though all went well.
			case 400:     // optimistic locking: update conflict has happened.
				message.show( "(" + xhr.status + "): " + i18n.ErrUpdateConflict, 'warning', CONFIG.messageDisplayTimeLong );
//					self.merge();
				return;
			default:
				handleError( xhr )
		}
	};

	self.show = function( creOL ) {
		// creOL is a list of objectType ids, which carry permission for the current user to create an object instance ( 'cre' is true )
		// and which allow manual creation of object instances (creation contains 'user').
		if( !creOL || myProject==null || myProject.selectedSpec==null ) return false;
		if( (self.mode()=='update' || self.mode()=='clone' ) && !specs.tree.selectedNode ) return false;

		if( specs.tree.selectedNode && specs.tree.selectedNode.ref ) 
			selectedObject = { id: specs.tree.selectedNode.ref };
		console.debug( "objectEdit.show", creOL, myProject.selectedSpec, selectedObject, self.mode() );

		setContentHeight('new');
		projects.busy.set( true );
		storing = false;

		// Store all object types for which the user has creation right and which are marked for user creation in self.eligibleObjTypes:
		//   creOL is a list of ids of those object types, for which the current user has creation right.
		self.eligibleObjTypes.removeAll(); 
		var creO = null;  
		for( var r=0,R=creOL.length;r<R;r++ ) {
			// The object type is eligible for creation, if creation mode is not specified or 'user' is listed:
			// AND if there is at least one attribute (this has been checked before, already, and thus creOL has only such elements)
			creO = itemById( myProject.objTypes, creOL[r] );
//			console.debug('creo',creO,creO.instantiation.indexOf( 'user' ));
			if( !creO.instantiation || creO.instantiation.indexOf( 'user' )>-1 ) {
				self.eligibleObjTypes.push( creO )
			}
		};
//		console.debug('eligibleObjTypes',self.eligibleObjTypes() );

		// Get the files to choose from for insertion:		
		myProject.readContent( 'file', 'all', {reload: true} )
			.done(function(fL) {   
				for( var f=0,F=fL.length;f<F;f++ ) {
					if( fL[f].type.startsWith( 'image/' ) ) 
						self.images.push({
							id: fL[f].id,
							type: fL[f].type
						})
				};
				self.images.sort(function(a,b) { return a.id.toLowerCase() > b.id.toLowerCase() })
			})
			.fail( handleError );
		
		switch( self.mode() ) {
			case 'new':
				// we (should ;-) get here only if eligibleObjTypes has at least one element:
				fillNewObj( self.eligibleObjTypes()[0] );
				projects.busy.set( false );
				let btns = doneBtns();
				$( '#contentActions' ).html( btns );
				$( '#editDoneBtns' ).html( btns );
				break;
			case 'update':
			case 'clone':
				// Get latest data from server to minimize the risk of an update conflict,
				// just specify the id to obtain the last revision:
				return myProject.readContent( 'object', {id:selectedObject.id}, {reload: true} )
					.done( function(rsp) {
						// clone has same permissions ..
						selectedObject = rsp;
						fillObjE( rsp ); 
						projects.busy.set( false );
						let btns = doneBtns();
						$( '#contentActions' ).html( btns );
						$( '#editDoneBtns' ).html( btns )
					})
					.fail( handleError )
		}
	};
	function integerVM() {
		var self = this;
		self.content = ko.observable();
		self.valid = ko.pureComputed( function() {
			return (self.content().length==0 ||
					( RE.Integer.test( self.content() ) &&
					self.content() >= self.valueRange.min && 
					self.content() <= self.valueRange.max ))
		});
		self.validClass = ko.pureComputed( function() {
			// ToDo: 'objectEdit' should not be referenced here. Was not able to use self.*, though.
			objectEdit.checkAllAtts();
			return self.valid() ? "has-success" : "has-error";
		});
	};
	function realVM() {
		var self = this;
		self.content = ko.observable();
		self.valid = ko.pureComputed( function() {
//			console.debug('real',self.content(),re.test(self.content()),self.content() >= self.valueRange.min,self.content() <= self.valueRange.max );
			return ( self.content().length==0 ||
					( RE.Real( self.valueRange.accuracy ).test( self.content() ) &&
					self.content() >= self.valueRange.min && 
					self.content() <= self.valueRange.max ))
		});
		self.validClass = ko.pureComputed( function() {
			// ToDo: 'objectEdit' should not be referenced here. Was not able to use self.*, though.
			objectEdit.checkAllAtts();
			return self.valid() ? "has-success" : "has-error";
		});
	};
	function isoDateVM() {
		var self = this;
		self.content = ko.observable();
		self.valid = ko.pureComputed( function() {
//			console.debug('date',self.content(),RE.IsoDate.test(self.content()));
			return ( self.content().length==0 || RE.IsoDate.test(self.content()) );
		});
		self.validClass = ko.pureComputed( function() {
			// ToDo: 'objectEdit' should not be referenced here. Was not able to use self.*, though.
			objectEdit.checkAllAtts();
			return self.valid() ? "has-success" : "has-error";
		});
	};
	function booleanVM() {
		var self = this;
		self.content = ko.observable();
		self.valid = function() {
			return true;
		};
	};
	function enumVM() {
		var self = this;
/*		// example of a filled options list for an enumerated attribute with multiple choice:
		// the 'selected' properties are used to convey the data only in case of multi-valued enums:
		self.options = 
			[{optLabel:'cyan', optID:'V-color-0', selected:true},
			{optLabel:'magenta', optID:'V-color-1', selected:true},
			{optLabel:'yellow', optID:'V-color-2', selected:false}]; 
*/		self.options = [];
		// The 'contentID' property is used to convey the data only in case of single-valued enums:
		self.contentID = ko.observable();  
		// The 'content' is for display only (when there is no update permission):
		self.content = ko.observable();  
		self.valid = function() {
			return true;
		};
	};
	function xhtmlVM() {
		var self = this;
		self.content = '';
		self.sceditorInstance = null;
		self.valid = function() {
			return true;
		};
	};
	// 'TEXT' and 'STRING':
	function stringVM() {
		var self = this;
		self.content = ko.observable();
		self.valid = function() {
			return (self.content().length<=self.valueRange.maxLength)
		};
		self.validClass = ko.pureComputed( function() {
			// ToDo: 'objectEdit' should not be referenced here. Was not able to use self.*, though.
			objectEdit.checkAllAtts();
			return self.valid() ? "has-success" : "has-error";
		});
	};
	self.allValid = ko.observable( true );
	self.checkAllAtts = function() {
		var res = false;
		if( self.objE() && self.objE().attributes() ) {
			res = true;
			for( var a=self.objE().attributes().length-1;a>-1;a-- ) {
				res = res && self.objE().attributes()[a].valid()
			}
		};
		self.allValid( res );
		return res
	}
	function fillNewObj( selT ) {
		// initResource() returns an empty object with all attributes according to the specType:
//		console.debug('fillNewObj',selT);
		if( selT ) self.selectedObjType( selT );
		if( !self.selectedObjType() ) return null;
		return myProject.initResource( self.selectedObjType() )
			.done( function(rsp) {
				// returns an initialized object of the requested type:
//				console.debug('fillNewObj',rsp);
				selectedObject = rsp;
				fillObjE( rsp )	// all the attributes of rsp have upd-permissions set
			})
			.fail( handleError )
	}
	function fillObjE( obj ) {
		// in case of cloning, all attributes shall be editable regardless of the permissions of the cloned object:
		// if the user has creation rights (needed for cloning) he will get update rights for all attributes when cloning.
	
			function enumValueRange(aT) {
				// Look up the dataType and return a list with all possible enumerated values:
				let dT = itemById( myProject.dataTypes, aT.dataType );
				if( dT ) {
					return forAll( dT.values, function(el) {
													return {
														optLabel: el.title, 
														optID: el.id, 
														selected: false
													}
												})
				};
				return null  // this should never happen ...
			}

		let oT = itemById( myProject.objTypes, obj.specType ),
			oa=null, p=null, cL=null, aT=null, dT=null, bT=null, a, A,
			pL = normalizeAtts( oT.attributeTypes, obj.attributes );

		self.objE().attributes.removeAll();
		// Create an input field per attribute:
		for( a=0, A=pL.length; a<A; a++ ) { 
			oa = pL[a];
			aT = itemById( oT.attributeTypes, oa.attributeType );	// attributeType
			dT = itemById( myProject.dataTypes, aT.dataType );		// dataType
			bT = dT.type;											// baseType
			switch( bT ) {
				case 'INTEGER':
					var att = new integerVM();
					att.baseType = bT;  // for type-sensitive edit forms
					att.valueRange = dT;
					att.content( oa.content );
					break;
				case 'REAL':
					var att = new realVM();
					att.baseType = bT;  // for type-sensitive edit forms
					att.valueRange = dT;
					att.content( oa.content );
					break;
				case 'DATETIME':
					var att = new isoDateVM();
					att.baseType = bT;  // for type-sensitive edit forms
					att.content( oa.content );
					break;
				case 'BOOLEAN':
					var att = new booleanVM();
					att.baseType = bT;  // for type-sensitive edit forms
					att.content( oa.content.isTrue() );  // convert oa.content to boolean value
					break;
				case 'ENUMERATION':
					var att = new enumVM();
					att.baseType = bT;  // for type-sensitive edit forms
					att.multiple = multipleChoice( aT );
					att.options = enumValueRange( aT );
					cL = oa.content.split(',');
					if( att.multiple ) {
						// multi-valued enum: the 'selected' properties are used to convey the data
						var o=null,O=null;
						for( var v=cL.length-1; v>-1; v-- ) {
							for( o=att.options.length-1; o>-1; o-- ) {
								if( cL[v] == att.options[o].optID)
									att.options[o].selected = true
							}
						}
					} else {
						// single-valued enum: The 'contentID' property is used to convey the data
						if( cL.length>0 )
							att.contentID( cL[0] )
					};
					att.content( enumValStr(dT,oa) );	// replace value-IDs with titles
					break;
				case 'XHTML':
					var att = new xhtmlVM();
					att.baseType = bT;  // for type-sensitive edit forms
					att.content = oa.content.trim();
					// remove any plain div pair embracing the content:
//					att.content = att.content.replace( /^<div>([\s\S]*)<\/div>$/g, function( $0, $1 ){ return $1 });
					// replace a comprehensive object tag by a paired one, because the xhtml editor seems to duplicate the former:
					att.content = att.content.replace( /<object([^>]+)\/>/g, function($0,$1) {
																let nm = /name="([^"])"/.exec($1) || objTitleOf(obj);
																return '<object'+$1+'>'+nm+'</object>'
														});
					// The attribute must be shown with images:
					if( !oa.upd )
						att.content = fileRef.toGUI( att.content, {rev:obj.revision} );
//					else
//						ToDo: show a small icon in the edit window to represent the image - must be removed before saving.

//					console.debug('xhtml',att.content);
					break;
				case 'STRING':
					var att = new stringVM();
					att.valueRange = dT;

					if( dT.maxLength>CONFIG.textThreshold ) 
						att.baseType = 'TEXT'  	// display a textarea
					else
						att.baseType = bT;  	// display a single-line input field
					
					if( !oa.upd && oa.longName==CONFIG.stereotype )
						att.content = '&#x00ab;'+oa.content+'&#x00bb;'
					else
						att.content( oa.content );
					break;
				default:
					console.error("Encountered invalid dataType '",bT,"' of object '",obj.id,"'");
			};
			// add the properties common to all attribute types:
			att.longName = oa.longName;
			att.title = titleOf(oa);
			att.type = oa.attributeType;
			att.upd = oa.upd;
			att.attrTypeDesc = aT.description;	// for popup in edit dialog
//			console.debug('att',dT.maxLength,att)
			self.objE().attributes.push( att );

			if( att.baseType=='XHTML' && att.upd ) {
				// initialize the editor for the HTML textarea created above:
				self.objE().attributes()[a].sceditorInstance = initEditor( att.title.toJsId() )
			}
		}
	}
	function applyChanges( obj ) {
		// apply to obj all changes made to objE:
		storing = true;						// avoid multiple storing of the same data
		let oa=null, p=null,
			oT=itemById( myProject.objTypes, obj.specType ),
			oE=self.objE();		// the previously edited object

		obj.attributes.length = 0;
		for( var a=0,A=oE.attributes().length; a<A; a++ ) { 
			oa = oE.attributes()[a];
			console.debug('applyChanges',obj,oT,oE,oa);
//			if( oa.upd ) {
				let aT = itemById( oT.attributeTypes, oa.type ),
					dT = itemById( myProject.dataTypes, aT.dataType );
				// attributes to be stored get exceptionally a baseType attribute to simplify the processing:
//				oa.baseType = dT.type;
				p = {
					longName: oa.longName,
					attributeType: oa.type,
					upd: aT.upd,
					del: aT.del
				};
				switch( dT.type ) {
					case 'ENUMERATION':
						p.content = '';
						if( oa.multiple ) {
							console.debug('-m-',self.objE().attributes()[a].options);
							for( var o=0, O=oa.options.length; o<O; o++ ) {
								if( oa.options[o].selected )
									p.content += (p.content.length<1?'':',')+oa.options[o].optID
							}
						} else {
							// singleValued, take value only if not null:
							console.debug('-s-',self.objE().attributes()[a].contentID());
							if( oa.contentID() )
								p.content = oa.contentID()
						};
						break;
					case 'XHTML':
						// sometimes the editor adds <br _moz_editor_bogus_node="TRUE" />, but ReqIF does not allow it. 
						let c = oa.sceditorInstance.val().replace( /<br\s+\w*bogus[^\s]*\s*\/>/, '' );
						// if missing, add a <div>...</div> bracket, as RIF/ReqIF requires it:
						// ToDo: multiple <div> sections pass, but they shouldn't.
						if( /^[\s]*<div>([\s\S]*)<\/div>[\s]*$/.test(c) )
							p.content = c
						else
							p.content = '<div>'+c+'</div>';
						oa.sceditorInstance.destroy();
						break;
					default:
						p.content = oa.content()
				};
//			};
			// store the attribute only, if it has a value / content.
			if( p.content )
				obj.attributes.push( p )
		};
		switch( self.mode() ) {
			case 'clone':
				delete obj.createdAt;
				delete obj.createdBy;
			case 'update':
				delete obj.changedAt;
				delete obj.changedBy
		};
		// finally set the object title from the configured title attribute:
		obj.longName = titleFromAttributes(obj.attributes);
		console.debug('applyChanges',obj)
		return obj
	};

/*	// Correct input when create() or update() calls have been rejected with error:
	self.correct = function() {
	};
	// Resolve update conflict:
	self.merge = function() {
		// get the current object (after someone else has updated it)
		// compare with the own updates
		// merge
		// store
	};
*/
	// Switch the type when creating a new object:
	self.switchObjType = function( sT ) {
//		console.debug( 'switch to: ', sT.title );
		return fillNewObj( sT );
	};

	// ToDo: missing cases:
	// - insert as first element in the tree, i.e. predecessor of the current first element
	self.insertSuccessor = function() {
		if( storing ) return;

		// create object and insert as successor in the tree:
		applyChanges( selectedObject );
		var oId = genID('R-');
		selectedObject.id = oId;		// assign a new ID, especially when cloning 
		delete selectedObject.revision; // in case of cloning, do not use the original's revision
//		console.debug( 'insertSuccessor',selectedObject );
		// insert it after the selected item, if at least one attribute is editable 
//		if( selectedObject && selectedObject.attributes.length )	// should always be true in a regular situation.
			myProject.createContent( 'object', selectedObject )
				.done( function() {
					// The user may choose the reference node before saving, so get the currently selected node:
					if( specs.tree.selectedNode )
						var selN = specs.tree.selectedNode
					else {
						// assume last node on top level (if the tree is empty, execution should never arrive here ...):
						var selN = specs.tree.get();
						selN = selN.children[selN.children.length-1];  
					}; 

					// Insert the new entry in the cache and server as successor of the currently selected node:
					var parentId = selN.parent.id;  
					// on the first level, 'parent.id' is undefined:
					if( !parentId ) { parentId = myProject.selectedSpec.id };

					var en = { 
							id: genID('N-'), 
							ref: oId,
							name: objTitleOf( selectedObject ),
							children: [],
							parent: parentId,
							predecessor: selN.id 
						}; 
//					console.debug( 'insert after: ', selN.id, en );
					
					myProject.createNode(en)
						.done( function() {
							specs.buildTree();
						//	specs.tree.moveDown();  // select the inserted node
						//	selN = selN.getNextSibling();
//							console.debug( 'insert after: ', selN );
							specs.tree.selectNode( specs.tree.selectedNode.getNextSibling() );  // select the inserted node, where the current node may have children
							returnOnSuccess()
						})
						.fail( handleError )
				})  
				.fail( handleError )
	};
	self.insertChild = function() {
		if( storing ) return;

		// create object and insert as child in the tree:
		applyChanges( selectedObject );
		var oId = genID('R-');
		selectedObject.id = oId;		// assign a new ID, especially when cloning 
		delete selectedObject.revision; // in case of cloning, do not use the original's revision
//		console.debug( 'insertChild',selectedObject );
		// insert it after the selected item, if at least one attribute is editable 
//		if( selectedObject && selectedObject.attributes.length )	// should always be true in a regular situation.
			myProject.createContent( 'object', selectedObject )
				.done( function() {
					// The user may choose the reference node before saving, so get the currently selected node:
					// assume root node, if none is selected:
					var selN = specs.tree.selectedNode || {id:myProject.selectedSpec.id};
					// Insert the new entry in the cache and server as child of the currently selected node:
					var en = { 
							id: genID('N-'), 
							ref: oId,
							name: objTitleOf( selectedObject ),
							children: [],
							parent: selN.id
							}; 
//					console.debug( 'insert below: ', selN.id, en );
					
					myProject.createNode(en)
						.done( function() {
							specs.buildTree();
							specs.tree.openNode();
							specs.tree.moveDown();  // select the inserted node
							returnOnSuccess()
						})
						.fail( handleError )
				})  
				.fail( handleError );
	};
	self.update = function() {
		if( storing ) return;

		applyChanges( selectedObject );
//		console.debug( 'object.update', selectedObject );
		// ... and send it, if at least one attribute is editable 
		// (in fact, if none is editable, we should never arrive here):
		if( selectedObject.attributes.length ) {
			// Update the title(s) shown in the tree
			let newT = {name: objTitleOf( selectedObject )},
				nodesToChange = specs.tree.nodesByRef( selectedObject );
			for( var i=0, I=nodesToChange.length; i<I; i++ ) {
				specs.tree.updateNode( nodesToChange[i], newT );
			};
			myProject.updateContent( 'object', selectedObject )
				.fail( handleUpdateError )
		};
		returnOnSuccess()
	};
	self.uploadImg = function() {
        let f = document.getElementById('uploadAttachment').files[0];
//		console.debug( 'Upload: ', f );

		var rdr = new FileReader();
		rdr.onload = function(evt) {
			sendBuf( evt.target.result, f )
		};
		rdr.readAsArrayBuffer( f )

			function sendBuf( b, file ) {
				myProject.createContent( 'file', {blob:b,id:file.name,type:file.type} )
					.done(function(rsp,tst,xhr) { 
//						console.debug('objectEdit.uploadImg.done',rsp);
						self.images.unshift({
//							img: '<img src="'+CONFIG.serverURL+'/projects/'+myProject.id+'/files/'+rsp.id+'" type="'+rsp.type+'" />',
							id: f.name
						})
					})
					.fail( handleError )
			}
	};

	self.cancel = function() {
//		console.debug( 'cancel edit' );
		for( var i=self.objE().attributes().length-1;i>-1;i-- ) {
			// Destroy all instantiated editor instances. 
			// Under normal (error-free) circumstances all sceditorInstances are != null, when getting here:
			if( self.objE().attributes()[i].baseType=='XHTML' && self.objE().attributes()[i].sceditorInstance )
				self.objE().attributes()[i].sceditorInstance.destroy()
		};
		returnOnSuccess()
	};
	// for rendering and inserting with jQuery - unfortunately the 'onclick' are not reliable with IE and chrome, here.
	function doneBtns() {
		var rB = ''; // rendered buttons
		rB += '<button onclick="objectEdit.cancel()" class="btn btn-default btn-sm" >'+i18n.BtnCancel+'</button> ';
		if( self.mode() == 'update' ) {
			if( self.allValid() ) 
				rB += '<button onclick="objectEdit.update()" class="btn btn-primary btn-sm" >'+i18n.BtnSave+'</button>'
			else
				rB += '<button disabled class="btn btn-primary btn-sm" >'+i18n.BtnSave+'</button>'
		} else {
			// mode is 'new' or 'clone':
			if( self.allValid() ) {
				if( specs.tree.firstNode() )	// the tree has at least one element
					rB += '<button onclick="objectEdit.insertSuccessor()" class="btn btn-primary btn-sm" >'+i18n.BtnInsertSuccessor+'</button> ';
				rB += '<button onclick="objectEdit.insertChild()" class="btn btn-primary btn-sm" >'+i18n.BtnInsertChild+'</button>'
			} else {
				if( specs.tree.firstNode() )	// the tree has at least one element
					rB += '<button disabled class="btn btn-primary btn-sm" >'+i18n.BtnInsertSuccessor+'</button> ';
				rB += '<button disabled class="btn btn-primary btn-sm" >'+i18n.BtnInsertChild+'</button>'
			}
		};
		return rB	// return rendered buttons for display
	}

	return self

	// The custom editor command to add an image. 
	// To be called after loading and before creating instances of the editor: see self.open().
	// http://www.sceditor.com/posts/how-to-add-custom-commands/
	function setEditorCmds() {
		function insertTag( tag, edt ) {
			// Insertion tag in the editor window:
			var reImg = /(<img)([^>]+>)/;
			// if the clicked element is not the image, ignore the event:
			if( !reImg.test(tag) ) return;
			
			var width = $('#selectImgWidth').val();
			// Add a width before inserting, if a valid input has been made:
			if( width.length && /^[0-9]+$/.test(width) ) {
				tag = tag.replace( reImg,  
					function( $0, $1, $2 ){ 
						return $1 + ' style="width:'+width+'px"'+ $2
					})
			};
			edt.insert( tag );
//			$('#selectImgTable').off()
			$('#selectImg').modal('hide')
		};
		
		$.sceditor.command.set("image", {
			// Define a new handler for inserting images with the 'wysiwyg Editor':
			exec: function (caller) {
				// 'caller' is the commands HTML button element or null.
				// Store the editor instance for the click handler:
				var editor = this;
				// Show modal dialog to select an ingested image or to upload a new one:
				$('#selectImg').modal('show');
				// Bind event handler to the table:
				$('#selectImgTable').one('click', function(evt) {insertTag(evt.target.outerHTML, editor)})  // The event.target gives us the element clicked ... 
//				$('#selectImgTable img').on('click', function(evt) {insertTag(evt.target, editor)})  // works for all original elements in the list, but not for any newly uploaded image.
				// (http://stackoverflow.com/questions/4337582/do-events-handlers-on-a-dom-node-get-deleted-with-the-node) 
			},
			// The same for the 'Source Editor':
			txtExec: function (caller) {
				var editor = this;
				$('#selectImg').modal('show');
				$('#selectImgTable').one('click', function(evt) {insertTag(evt.target.outerHTML, editor)})
			}
		})
	}
	// create an instance of the editor:
	function initEditor( id ) {
		id = '#'+id;
		$(id).sceditor(sceditorOpts);
		return $(id).sceditor("instance")
	}
/*	function selectImg() {
		let dlg = new BootstrapDialog({
			title: i18n.MsgSelectImg,
			type: 'type-default',
			message: function (thisDlg) {
					function imgTable(fL) {
						var rF =
							'<div>';
						for( var i=0,I=fL.length;i<I;i++ ) {
							rF += '<div id="'+fL[i].id.simpleHash()+'" class="image-tile" />';
						};
						rF += 
							'</div>'
						return rF
					}
				var form = $('<form id="attrInput" role="form" class="form-horizontal" ></form>');
				form.append( textInput( i18n.MsgImgWidth, '', 'line' ) );
				for( var i=0,I=self.images.length;i<I;i++ ) {
				}
				return form },
			buttons: [{
					label: i18n.BtnCancel,
					action: function(thisDlg){ 
						jDO.reject({status: 1, statusText:'Cancelled'});
						thisDlg.close() 
					}
				},{ 	
					label: i18n.BtnSave,
					cssClass: 'btn-success', 
					action: function (thisDlg) {
						mode = modes[ radioValue( 'Import Mode' ) ];
						// save according to the selected mode:
						switch( mode.id ) {
							case 'clone': 	
								data.id = genID('P-');
								// no break
							case 'replace':
								jDO.notify('Creating project',20); 
								myProject.create( data )
									.progress( jDO.notify )
									.done( jDO.resolve )
									.fail( jDO.reject );
								break;
							case 'update':
								// First, load the project for comparison:
								jDO.notify('Updating project',20); 
								myProject.read({id:data.id}, {reload:true})	// reload from server
									.done( function(refD) {
//											console.debug('specif.update',refD,data)
										// ... then start to save the new or updated elements:
										myProject.update( data, 'extend' )
											.progress( jDO.notify )
											.done( jDO.resolve )
											.fail( jDO.reject )
									})
									.fail( jDO.reject )
						};
						thisDlg.close()
					}
				}]
		})
		.open()
	}  
*/
};
var objectEdit = new ObjectEditVM();
ko.applyBindings( objectEdit, $('#objectEditT')[0] );
		
</script>

<div id="objectEditT" >	
	<form class="form-horizontal" role="form" >
		<!-- ko if: mode()=='new' -->
					<div class="row form-group">
						<label class="col-sm-2 control-label input-sm" data-bind="html: i18n.LblObjectType"></label>
						<div class="col-sm-10 btn-group" data-bind="foreach: eligibleObjTypes()">
							<!-- the anonymous function wrapper for the click event avoids the firing on page load ... -->
							<button data-toggle="popover" data-bind="html: titleOf($data), css: { active: $parent.selectedObjType().id == id }, click: function() {$parent.switchObjType( $data )}, attr: {title: $data.description}" class="btn btn-default btn-sm"></button>
						</div>
					</div>
		<!-- /ko -->
		<!-- ko foreach: objE().attributes -->
			<!-- ko if: !upd -->
					<div class="row form-group">
						<label class="col-sm-2 control-label input-sm" data-bind="html: title"></label>
						<div class="col-sm-10" style="margin-top: 0.4em" data-bind="html: content"></div>
					</div>
			<!-- /ko -->
			<!-- ko if: upd -->
				<!-- ko if: (baseType=='STRING' || baseType=='INTEGER' || baseType=='REAL' || baseType == 'DATETIME') -->
					<div class="row form-group form-active" data-bind="css: $data.validClass">
						<label class="col-sm-2 control-label input-sm" data-toggle="popover" data-bind="html: title, attr: {title: $data.attrTypeDesc}"></label>
						<div class="col-sm-10">
							<input type="text" class="form-control" data-bind="textInput: content"></input>
						</div>
					</div>
				<!-- /ko -->
				<!-- ko if: (baseType == 'TEXT') -->
					<div class="row form-group form-active" data-bind="css: $data.validClass">
						<label class="col-sm-2 control-label input-sm" data-toggle="popover" data-bind="html: title, attr: {title: $data.attrTypeDesc}"></label>
						<div class="col-sm-10">
							<textarea class="form-control" rows="7" data-bind="textInput: content"></textarea>
						</div>
					</div>
				<!-- /ko -->
				<!-- ko if: (baseType == 'XHTML') -->
					<div class="row form-group form-active" >
						<label class="col-sm-2 control-label input-sm" data-toggle="popover" data-bind="html: title, attr: {title: $data.attrTypeDesc}"></label>
						<div class="col-sm-10">
							<textarea class="formatted" style="height:300px;width:100%" data-bind="textInput: content, attr: {id: title.toJsId()}"></textarea>
						</div>
					</div>
				<!-- /ko -->
				<!-- ko if: (baseType == 'BOOLEAN') -->
					<div class="row form-group form-active" >
						<label class="col-sm-2 control-label input-sm" data-toggle="popover" data-bind="html: title, attr: {title: $data.attrTypeDesc}"></label>
						<div class="col-sm-10 checkbox">
							<label><input type="checkbox" data-bind="checked: content" ></input></label><br />
						</div>
					</div>
				<!-- /ko -->
				<!-- ko if: (baseType == 'ENUMERATION' && !type.multiple) -->
					<div class="row form-group form-active" >
						<label class="col-sm-2 control-label input-sm" data-toggle="popover" data-bind="html: title, attr: {title: $data.attrTypeDesc}"></label>
						<div class="col-sm-10 radio">
							<!-- ko foreach: options -->
								<label><input type="radio" data-bind="checked: $parent.contentID, attr: {value: optID}" ></input><span data-bind="html: optLabel"></span></label><br />
							<!-- /ko -->
						</div>
					</div>
				<!-- /ko -->
				<!-- ko if: (baseType == 'ENUMERATION' && type.multiple) -->
					<div class="row form-group form-active" >
						<label class="col-sm-2 control-label input-sm" data-toggle="popover" data-bind="html: title, attr: {title: $data.attrTypeDesc}"></label>
						<div class="col-sm-10 checkbox">
							<!-- ko foreach: options -->
								<label><input type="checkbox" data-bind="checked: selected" ></input><span data-bind="html: optLabel"></span></label><br />
							<!-- /ko -->
						</div>
					</div>
				<!-- /ko -->
			<!-- /ko -->
		<!-- /ko -->

	</form>
	<div id="editDoneBtns" class="btn-group btn-group-sm doneBtns" ></div>

	<div id="selectImg" class="modal fade">
		<div class="modal-dialog">
		  <div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
				<h4 class="modal-title" data-bind="html: i18n.MsgSelectImg" />
			</div>
			<div class="modal-body">
				<div class="row form-group form-active" >
					<label class="col-sm-4 control-label input-sm" data-bind="html: i18n.MsgImgWidth" ></label>
					<div class="col-sm-8">
						<input type="text" id="selectImgWidth" class="form-control" ></input>
					</div>
				</div>
				<!-- ko if: ( specs.filCre ) -->
					<span class="btn btn-primary btn-fileinput btn-sm" style="margin-bottom:0.4em" >
						<span id="FileSelect" data-bind="html: i18n.BtnFileSelect" ></span>
						<input id="uploadAttachment" type="file" onchange="objectEdit.uploadImg()" ></input><!-- (no 'multiple' attribute) -->
					</span>
				<!-- /ko -->
					<table id="selectImgTable" class="table table-striped table-condensed">
						<tbody data-bind="foreach: images" >
							<tr><td><div class="forImagePreview" data-bind="html: img" ></div></td><td><div data-bind="html: id" ></div></td></tr>
						</tbody>
					</table>
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal" data-bind="html: i18n.BtnCancel" ></button>
			</div>
		  </div><!-- /.modal-content -->
		</div><!-- /.modal-dialog -->
	</div><!-- /.modal -->

</div>  <!-- id="objectEditT" -->

