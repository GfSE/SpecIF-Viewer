///////////////////////////////
/*	Cache Library for SpecIF data.
	Dependencies: jQuery
	(C)copyright 2010-2019 enso managers gmbh (http://www.enso-managers.de)
	Author: se@enso-managers.de, Berlin
	License: Apache 2.0 (http://www.apache.org/licenses/LICENSE-2.0)
	We appreciate any correction, comment or contribution via e-mail to support@reqif.de            

	Naming:
	- readX: Get it from cache, if available, or otherwise from the server. Is always asynchronous.
	- loadX: Get it from the server and update the cache
	- cacheX: Add to cache
	- createX: Create a new instance of the specified data which is also cached.
	- updateX: Add non-existing instances and update existing instances. The cache is updated.
	
	Note:
	- No error handling - it is left to the calling layers
*/

modules.construct({
	name: 'cache'
}, function(self) {
	"use strict";
	// Construct a representative of the selected project with cached data:
	// ToDo: enforce CONFIG.maxObjToCacheCount
	var autoLoadId = null,		// max 1 autoLoad chain
		autoLoadCb = null,		// callback function when the cache has been updated
		loading = false;		// true: data is being gathered from the server.
	self.exporting = false;		// prevent concurrent exports
//	self.cacheInstances = server && server.type=='ReqIF Server';  ... too much depends on self.resources, for now
	self.cacheInstances = true;
	
	// initialization is at the end of this constructor.
	self.init = function() {
//		console.debug( 'cache.init' );
		self.clear();
		return true
	};
	self.clear = function() {
		// initialize/clear all variables:
		self.id = '';
		self.title = '';
		self.description = '';
		self.generator = '';
		self.generatorVersion = '';
		self.myRole = null;
		self.cre = null;
		self.upd = null;
		self.del = null;
		self.exp = null;
		self.locked = null;		// the server has locked the project ( readOnly )

		self.dataTypes = [];
		self.allClasses = []; 	// common list of all resourceClasses, statementClasses and hierarchyClasses
		self.propertyClasses = [];
		self.resourceClasses = [];
		self.statementClasses = [];
		self.hierarchyClasses = [];		// list of specification (hierarchy root) types
		self.resources = [];   	// list of resources as referenced by the hierarchies
		self.statements = [];
		self.hierarchies = [];    	// listed specifications (aka hierarchies, outlines) of the project.   
		self.selectedHierarchy = null;  // the currently worked-on hierarchy
		self.files = [];

		autoLoadId = null;  // stop any autoLoad chain
		autoLoadCb = null;
		loading = false;
		self.exporting = false;
		self.createdAt = null;
		self.createdBy = null
	};

	self.create = function( prj ) {
		// create a project, if there is no project with the given id, or replace a project with the same id.
		// (The roles/permissions and the role assignment to users are preserved, when import via ReqIF-file is made)
		// If there is no prj.id, it will be generated by the server.
		if( !prj ) return null;
		var pend=0,
			sDO = $.Deferred();
		if( !prj ) {
			sDO.reject({
				status: 995,
				statusText: i18n.MsgImportFailed
			});
			return sDO
		};
//		console.debug('myProject.create',prj);

		self.abortFlag = false;

		// ToDo: schema and consistency check
		// Create the specified project:
		self.clear();
		prj = self.set(prj);	// transform to internal data structure
		
		self.id = prj.id;
		self.title = prj.title;
		self.description = prj.description;
		self.generator = prj.generator;
		self.generatorVersion = prj.generatorVersion;
		self.myRole = i18n.LblRoleProjectAdmin;
	//	self.cre = self.upd = self.del = self.exp = self.parent.options.label!=i18n.LblReader;
		self.cre = self.upd = self.del = app.options.label!=i18n.LblReader;
		self.exp = true;

		// 1. Create the project with all types:
		// (The roles/permissions and the role assignment to users are preserved, when import via ReqIF-file is made)
		sDO.notify(i18n.MsgLoadingTypes,30);
		cache( 'dataType', prj.dataTypes );
		cache( 'propertyClass', prj.propertyClasses );
		cache( 'resourceClass', prj.resourceClasses );
		cache( 'statementClass', prj.statementClasses );
		cache( 'hierarchyClass', prj.hierarchyClasses );
		sDO.notify(i18n.MsgLoadingFiles,40);
		cache( 'file', prj.files );
		sDO.notify(i18n.MsgLoadingObjects,50);
		cache( 'resource', prj.resources );
		sDO.notify(i18n.MsgLoadingRelations,70);
		cache( 'statement', prj.statements );
		sDO.notify(i18n.MsgLoadingHierarchies,90);
		cache( 'hierarchy', prj.hierarchies );
		sDO.notify(i18n.MsgProjectCreated,100);

		self.locked = app.options.label==i18n.LblReader;	
		self.createdAt = prj.createdAt;
		self.createdBy = prj.createdBy;
		
		sDO.resolve({status:0});
		return sDO
	};
	self.read = function( prj, opts ) { 
		switch( typeof(opts) ) {
			case 'boolean':
				// for backward compatibility:
				opts = {reload: opts, loadAllSpecs: false, loadObjects: false, loadRelations: false};
				break;
			case 'object':
				// normal case (as designed):
//				if( typeof opts.reload!='boolean' ) opts.reload = false;
				break;
			default:
				opts = {reload: false}
		};

//		console.debug( 'cache.read', opts, self.id, prj );
		
		var pDO = $.Deferred();
		// Read from cache in certain cases:
		if( self.id && !opts.reload && ( !prj || prj.id==self.id ) ) {
			// return the loaded project:
			pDO.resolve( self );
			return pDO
		};
		// else
		return null	
	};
/*	self.updateMeta = function( prj ) {
		if( !prj ) return null;
		for( var p in prj ) self[p] = prj[p];			// update only the provided properties
		// Update the meta-data (header):
	//	return server.project(self).update()
			// Do not take the result, as it is not (yet) returned by the server.
	};
	self.update = function( newD, mode ) {		
		// newD is new data in 'internal' data structure
		// add new elements
		// update elements with the same id
		// exception: since types cannot be updated, return with error in case newD contains incompatible types
		// There are tree modes with respect to the types:
		//	- "match": if a type in newD is already present and it differs, quit with error-code
		//	- "extend": new propertyClasses are added
		//	- "ignore": new propertyClasses and all depending properties are ignored
		mode = mode || 'ignore';
//		console.debug('cache.update',newD,mode);
		var rc = {},
			uDO = $.Deferred();
	//	newD = self.set( newD );  // transform to internal data structure
		if( !newD ) {
			uDO.reject({
				status: 995,
				statusText: i18n.MsgImportFailed
			});
			return uDO
		};

		// In first pass check, if there is any incompatible type making an update impossible:
		rc = typesAreCompatible('dataType',mode);
		if( rc.status>0 ) {
			uDO.reject( rc );
			return uDO
		};
		rc = typesAreCompatible('resourceClass',mode);
		if( rc.status>0 ) {
			uDO.reject( rc );
			return uDO
		};
		rc = typesAreCompatible('statementClass',mode);
		if( rc.status>0 ) {
			uDO.reject( rc );
			return uDO
		};
		rc = typesAreCompatible('hierarchyClass',mode);
		if( rc.status>0 ) {
			uDO.reject( rc );
			return uDO
		};
		console.info("All existing types are compatible with '"+newD.title+"'");

		// In a second pass, start with creating any type which does not yet exist.
		// Start with the datatypes; the next steps will be chained by function updateNext:
		var pend=0;
		addNewTypes('dataType');

		return uDO
		
		function updateNext(ctg) {
			// chains the updating of types and elements in asynchronous operation:
			console.info('Finished updating:',ctg);
			// having finished with elements of category 'ctg', start next step:
			switch( ctg ) {
				case 'dataType': addNewTypes( 'resourceClass' ); break;
				case 'resourceClass': addNewTypes( 'statementClass' ); break;
				case 'statementClass': addNewTypes( 'hierarchyClass' ); break;
				case 'hierarchyClass': updateIfChanged( 'file' ); break;
				case 'file': updateIfChanged( 'resource' ); break;
				case 'resource': updateIfChanged( 'statement' ); break;
				case 'statement': updateIfChanged( 'hierarchy' ); break;
				case 'hierarchy': 
						uDO.notify(i18n.MsgProjectUpdated,100); 
						console.info('Project successfully updated');
						uDO.resolve(); 
						break;
				default: uDO.reject() //should never arrive here
			}
		}
		function typesAreCompatible( ctg, mode ) {
			let aL= null, nL= null; 
			switch( ctg ) {
				case 'dataType': aL = self.dataTypes; nL = newD.dataTypes; break;
				case 'resourceClass': aL = self.resourceClasses; nL = newD.resourceClasses; break;
				case 'statementClass': aL = self.statementClasses; nL = newD.statementClasses; break;
				case 'hierarchyClass': aL = self.hierarchyClasses; nL = newD.hierarchyClasses; break;
				default: return null //should never arrive here
			};
			// true, if every element in nL is compatibly present in aL or if it can be added;
			// loop backwards because only one variable is needed:
			let j=null, rC=null;
			for( var i=nL.length-1;i>-1;i-- ) {
				for( j=aL.length-1;j>-1;j-- ) {
//					console.debug('typesAreCompatible',aL[j],nL[i]);
					// if a single element is incompatible the lists are incompatible:
					rC = typeIsCompatible(aL[j],nL[i],mode);
					// on first error occurring, quit with return code:
					if( rC.status>0 ) return rC 
				}
			};
			return {status:0}
		}
		function typeIsCompatible(refT,newT,mode) {
			if(refT.id!=newT.id) return {status:0};
			if(refT.category!=newT.category) return {status:950, statusText:"new "+newT.category+" '"+titleOf(newT)+"' is incompatible"};
			// else: identifiers and categories are equal:
//			console.debug( 'typeIsCompatible', refT, newT );
			switch( newT.category ) {
				case 'dataType':
					// A dataType is incompatible, if an existing one has the same id and a smaller value range.
					// A dataType is compatible, if an existing one has the same id and an equal or larger value range.
					switch( refT.type ) {
						case 'xs:boolean':	
						case 'xs:double':	
							return {status:0};
						case 'xhtml':	
						case 'xs:string':
//							console.debug( refT.maxLength>newT.maxLength-1 );
							if ( refT.maxLength==undefined )
								return {status:0};
							if ( newT.maxLength==undefined || refT.maxLength<newT.maxLength )
								return {status:951, statusText:"new dataType '"+titleOf(newT)+"' of type '"+newT.type+"' is incompatible"};
							return {status:0};
						case 'xs:double':
							// to be compatible, the new 'accuracy' must be lower or equal:
							if( refT.accuracy<newT.accuracy )
								return {status:952, statusText:"new dataType '"+titleOf(newT)+"' of type '"+newT.type+"' is incompatible"};
							// else: go on ...
						case 'xs:integer':
							// to be compatible, the new 'max' must be lower or equal and the new 'min' must be higher or equal:
//							console.debug( refT.max<newT.max || refT.min>newT.min );
							if( refT.max<newT.max || refT.min>newT.min )
								return {status:953, statusText:"new dataType '"+titleOf(newT)+"' of type '"+newT.type+"' is incompatible"}
							else
								return {status:0};
						case 'xs:enumeration':
							// to be compatible, every value of the new 'enumeration' must be present in the present one:
							// ToDo: Add a new enum value to an existing enum dataType.
							var idx=null;
							for( var v=newT.values.length-1; v>-1; v-- ) {
								idx = indexById( refT.values, newT.values[v].id );
								// the id must be present:
								if( idx<0 ) 
									return {status:954, statusText:"new dataType '"+titleOf(newT)+"' of type '"+newT.type+"' is incompatible"};
								//  ... and the titles must be equal:
								if( refT.values[idx].title != newT.values[v].title )
									return {status:955, statusText:"new dataType '"+titleOf(newT)+"' of type '"+newT.type+"' is incompatible"}
							};
							return {status:0}
					};
					return null;	// should never arrive here ... as every branch in every case above has a return.
				case 'statementClass':
					// To be compatible, all sourceTypes of newT must be contained in the sourceTypes of refT;
					// no sourceTypes means that all objectTypes are permissible as subject.
					// ... and similarly for the targetTypes:
					if( refT.sourceTypes && !newT.sourceTypes
						|| refT.sourceTypes && newT.sourceTypes && !containsById( refT.sourceTypes, newT.sourceTypes ) ) {
								return {status:961, statusText:"new "+newT.category+" '"+titleOf(newT)+"' is incompatible"}
					};
					if( refT.targetTypes && !newT.targetTypes
						|| refT.targetTypes && newT.targetTypes && !containsById( refT.targetTypes, newT.targetTypes ) ) {
								return {status:962, statusText:"new "+newT.category+" '"+titleOf(newT)+"' is incompatible"}
					};
					// else: so far everything is OK, but go on checking ... (no break!)
				case 'resourceClass':
				case 'hierarchyClass':
					// An objectType, relationType or hierarchyType is incompatible, if it has an equally-named property class with a different dataType
					// An objectType, relationType or hierarchyType is compatible, if all equally-named propertyClasses have the same dataType
					if( !newT.propertyClasses || !newT.propertyClasses.length ) 
								return {status:0};
					// else: The new type has at least one property.
					if( mode=='match' && (!refT.propertyClasses || !refT.propertyClasses.length) ) 
								return {status:963, statusText:"new "+newT.category+" '"+titleOf(newT)+"' is incompatible"};
					var idx=null, pc=null;
					for( var a=newT.propertyClasses.length-1; a>-1; a-- ) {
						npc = newT.propertyClasses[a];
						if( npc.id ) {
							// If an id exists, it must be equal to one of refT's propertyClasses:
							idx = indexById( refT.propertyClasses, npc.id )
						} else {
							// If there is no id, the type is new and there are no referencing elements, yet. 
							// So it does not matter.
							// But there must be a property class with the same name:
							idx = indexByName( refT.propertyClasses, npc.title )
						};
						if( idx<0 ) {
							// The property class in the new data is not found in the existing (reference) data:
							if( mode=='match' )
								// the property class is expected and thus an error is signalled:
								return {status:964, statusText:"new "+newT.category+" '"+titleOf(newT)+"' is incompatible"}
							else
								// cases 'extend' and 'ignore';
								// either the property will be created later on, or it will be ignored;
								// we are checking only in a first pass.
								continue;
						};
						//  else: the property class is present; in this case and in all modes the dataTypes must be equal:
						if( refT.propertyClasses[idx].dataType != npc.dataType ) {
							return {status:965, statusText:"new "+newT.category+" '"+titleOf(newT)+"' is incompatible"}
						}
					};
					return {status:0}
			};
			return null		// should never arrive here ...
		}
		function addNewTypes( ctg ) {
			// Is commonly used for object, relation and hierarchy types with their property types.
			let rL= null, nL= null, rT=null, nT=null; 
			switch( ctg ) {
				case 'dataType': rL = self.dataTypes; nL = newD.dataTypes; break;
				case 'resourceClass': rL = self.resourceClasses; nL = newD.resourceClasses; break;
				case 'statementClass': rL = self.statementClasses; nL = newD.statementClasses; break;
				case 'hierarchyClass': rL = self.hierarchyClasses; nL = newD.hierarchyClasses; break;
				default: return null //should never arrive here
			};
			nL.forEach( function(nT) {
				rT = itemById(rL,nT.id);
				if( rT ) {
					// a type with the same id exists. 
					// ToDo: Add a new enum value to an existing enum dataType (server does not allow it yet)
					
					// Add a new property class to an existing type:
					switch( mode ) {
						case 'match': 
							// Reference and new data DO match (as checked, before) 
							// ... so nothing needs to be done, here.
							// no break
						case 'ignore':
							// later on, only properties for which the user has update permission will be considered,
							// ... so nothing needs to be done here, either.
							break;
						case 'extend': 
							// add all missing propertyClasses:
							// ToDo: Is it possible that the user does not have read permission for a property class ?? 
							// Then, if it is tried to create the supposedly missing property class, an error occurs.
							// But currently all *types* are visible for everybody, so there is no problem.
							if( nT.propertyClasses && nT.propertyClasses.length>0 ) {
								// must create missing propertyClasses one by one in ascending sequence, 
								// because a newly added property class can be specified as predecessor: 
								addNewAT( rT, nT.propertyClasses, 0 )
							}
					}
				} else {
					// else: the type does not exist and will be created, therefore:
					pend++;
					console.info('Creating type',nT.title);
					self.createContent(nT.category,nT)
						.done(function() {
							if( --pend<1 ) updateNext( ctg )
						})
						.fail( uDO.reject )
				}
			});
			// if no type needs to be created, continue with the next:
			if(pend<1) updateNext( ctg );
			return
				
				function addNewAT( r, nATs, idx ) {
					// r: existing (=reference) type with its propertyClasses
					// nATs: new list of propertyClasses
					// idx: current index of nATs
					if( nATs[idx].id?itemById( r.propertyClasses, nATs[idx].id ):itemByName( r.propertyClasses, nATs[idx].title ) ) {
						// not missing, so try next:
						if( ++idx<nATs.length ) addNewAT( r, nATs, idx );
						return
					};

					// else: not found, so create:
					pend++;
					if( idx>0 ) 
						nATs[idx].predecessor = nATs[idx-1].id;

					// add the new property class also to r:
					let p = indexById( r.propertyClasses, nATs[idx].predecessor );
					console.info('Creating property class', nATs[idx].title);
					// insert at the position similarly to the new type;
					// if p==-1, then it will be inserted at the first position:
					r.propertyClasses.splice( p+1, 0, nATs[idx] );
				//	nATs[idx].class = r.id;  // eine Verzweiflungstat ... siehe server...js
					server.project({id:self.id}).allClasses({id:r.id}).class(nATs[idx]).create()
						.done( function() {
							// Type creation must be completed before starting to update the elements:
							if( ++idx<nATs.length ) addNewAT( r, nATs, idx );
							if( --pend<1 ) updateNext( ctg )
						})
						.fail( uDO.reject )
				}
		}
		function updateIfChanged(ctg) {
			// Update a list of the specified category element by element, if changed.
			// Is commonly used for file, object, relation and hierarchy instances.
			// ToDo: Delete statements of all types provided by the import, which are missing 
			// ... not so easy to decide.
			// So perhaps restrict the deletion to those types with creation "auto" only.
			let itemL=null; 
			switch( ctg ) {
				case 'file': 
					uDO.notify(i18n.MsgLoadingFiles,40);
					// ToDo: check MD5 and upload any file only if changed.
					// For the time being, upload all files anyways. The server does not save duplicate blobs.
					// So we lose 'only' the transfer time.
					if( newD.files && newD.files.length>0 )
						self.updateContent(ctg,newD.files)
							.done( function() {
								// Wait for all files to be loaded, so that resources will have higher revision numbers:
								newD.files = [];
								updateNext(ctg)
							})
							.fail( uDO.reject )
					else
						updateNext(ctg);
					return;
				case 'resource': itemL = newD.resources; uDO.notify(i18n.MsgLoadingObjects,50); break;
				case 'statement': itemL = newD.statements; uDO.notify(i18n.MsgLoadingRelations,70); break;
				case 'hierarchy': itemL = newD.hierarchies; uDO.notify(i18n.MsgLoadingHierarchies,80); break;
				default: return null //should never arrive here
			};
			itemL.forEach( function(itm) {
				updateInstanceIfChanged(ctg,itm)
			});
			// if list is empty, continue directly with the next item type:
			if(pend<1) updateNext( ctg )
			return

			function contentChanged(ctg, r, n) { // ref and new resources
//				console.debug('contentChanged',ctg, r, n);
				// Is commonly used for object, relation and hierarchy instances.
				if( r['class']!=n['class'] ) return null;  // fatal error, they must be equal!
				
				// As long as the hierarchy roots do not use properties, the title carries the title,
				// so check whether the class of the new element is listed in the hierarchy types:
				if( ctg == 'hierarchy' ) return newD.hierarchyClasses.indexOf( n['class'] )<0 || r.title!=n.title;
				
				// Continue in case of resources and statements:
				let i=null, rA=null, nA=null, rV=null, nV=null;
				// 1) Are the property values equal?
				// Skipped, if the new instance does not have any property (list is empty or not present).
				// Relations and hierarchies often have no properties.
				// Objects without properties are useless, as they do not carry any user payload (information).
				// Note that the actual property list delivered by the server depends on the read privilege of the user.
				// Only the properties, for which the current user has update privilege, will be compared.
				// Use case: Update diagrams with model elements only:
				//		Create a user with update privileges for objectType 'diagram' 
				//		and property class 'title' of objectType 'model-element'.
				//		Then, only the diagrams and the title of the model-elements will be updated.
				if( n.properties && n.properties.length>0 ) {
					for( i=(r.properties?r.properties.length:0)-1;i>-1;i--) {
						rA = r.properties[i];
//						console.debug( 'update?', r, n);
						// no update, if the current user has no privilege:
						if( !rA.upd ) continue;	
						// look for the corresponding property:
						nA = itemBy( n.properties, 'class', rA['class'] );
						// no update, if there is no corresponding property in the new data:
						if( !nA ) continue;	
						// in all other cases compare the value:
						let oT = itemById( myProject.resourceClasses, n['class'] ),  // applies to both r and n
							rDT = dataTypeOf( myProject, rA['class'] ),
							nDT = dataTypeOf( newD, nA['class'] );
						if( rDT.type!=nDT.type ) return null;  // fatal error, they must be equal!
						switch( nDT.type ) {
							case 'xs:enumeration':
								// value has a comma-separated list of value-IDs,
								rV = enumValStr(rDT,rA);
								nV = enumValStr(nDT,nA);
//								console.debug('contentChanged','ENUM',rA,nA,rV!=nV);
								if( rV!=nV ) return true;
								break;
							case 'xhtml': 
						//		rV = toHex(rA.value.stripCtrl().reduceWhiteSpace());
						//		nV = toHex(fileRef.toServer(nA.value).stripCtrl().reduceWhiteSpace());
						//		rV = rA.value.stripCtrl().reduceWhiteSpace();
								rV = rA.value;
								// apply the same transformation to nV which has been applied to rV before storing:
						//		nV = fileRef.toServer(nA.value).stripCtrl().reduceWhiteSpace();
						//		nV = fileRef.toServer(nA.value);
								nV = nA.value;
						//		console.debug('contentChanged','xhtml',rA,nA,rV!=nV);
								if( rV!=nV ) return true;
								// If a file is referenced, pretend that the object has changed.
								// Note that a resource always references a file having the next lower revision number than istself.
								// It is possible that a file has been updated, so a referencing resource must be updated, as well.
								// ToDo: Analyse whether a referenced file has really been updated.
								if( RE.tagNestedObjects.test(nV)
									||  RE.tagSingleObject.test(nV) ) return true;
								break;
							default: 
								if( rA.value!=nA.value ) return true
						}
					}
				};
				// 2) Statements must have equal subjectClasses and objectClasses - with equal revisions?
				if( ctg == 'statement' ) {
	//				if( n.subject.id!=r.subject.id || n.subject.revision!=r.subject.revision) return true;
	//				if( n.object.id!=r.object.id || n.object.revision!=r.object.revision) return true;
					if( n.subject.id!=r.subject.id 
						|| n.object.id!=r.object.id ) return true
				};
				return false // ref and new are the same
			}
			function updateInstanceIfChanged(ctg,nI) {
				// Update an element/item of the specified category, if changed.
				pend++;
				self.readContent(ctg,nI,true)	// reload from the server to obtain most recent data
					.done( function(rI) {
						// compare actual and new item:
//						console.debug('updateInstanceIfChanged',ctg,rI,nI);
						// ToDo: Detect parallel changes and merge interactively ...
						if( Date.parse(rI.changedAt)<Date.parse(nI.changedAt) 
								&& contentChanged(ctg,rI,nI) ) {
							nI.revision = rI.revision; // avoid the optimistic locking 
							// properties without update permission will not be sent to the server:
							nI.upd = rI.upd;
							nI.del = rI.del;
							let nA=null;
							rI.properties.forEach( function(rA) {
								// in case the nI.properties are supplied in a different order:
								nA = itemBy(nI.properties,'class',rA['class']);
								if( nA ) {
									nA.upd = rA.upd;
									nA.del = rA.del
								}
							});
							console.info('Updating instance',nI.title);
							// ToDo: Test whether only supplied properties are updated by the server; otherwise implement the behavior, here.
							self.updateContent( ctg, nI )
								.done( updateTreeIfChanged( ctg, rI, nI ) )	// update the tree, if necessary.
								.fail( uDO.reject )
						} else {
							// no change, so continue directly:
							updateTreeIfChanged( ctg, rI, nI )	// update the tree, if necessary.
						}
					})
					.fail( function(xhr) {
						switch( xhr.status ) {
							case 403:
								// This is a hack to circumvent a server limitation.
								// In case the user is not admin, the server delivers 403, if an object does not exist,
								// whereas it delivers 404, if it is an admin.
								// Thus: If 403 is delivered and the user has read access according to the objectType,
								// do as if 404 had been delivered.
								var pT = itemById(myProject.allClasses,nI['class']);
//								console.debug('403 instead of 404',nI,pT);
								if( !pT.rea || !pT.cre ) { uDO.reject(xhr); return };
								// else the server should have delivered 404, so go on ...
							case 404:
//								console.debug('not found',xhr.status);
								// no item with this id, so create a new one:
								self.createContent(ctg,nI)
									.done(function() {
										if( --pend<1 ) updateNext( ctg )
									})
									.fail( uDO.reject )
								break;
							default: 
								uDO.reject(xhr)
						}
					})
			}
			function updateTreeIfChanged( ctg, aI, nI ) {
				// Update all children (nodes) of a hierarchy root.
				// This is a brute force solution, since any mismatch causes an update of the whole tree.
				// ToDo: Add or delete a single child as required.
				// ToDo: Update the smallest possible subtree in case addition or deletion of a single child is not sufficient.

					function newIds(h) {
						// new and updated hierarchy entries must have a new id (server does not support revisions for hierarchies):
						h.children.forEach( function(ch) {
							ch.id = genID('N-');
							newIds(ch)
						})
					}
					function treeChanged(a,n) {
						// Equal hierarchies?
						// All children (nodes in SpecIF terms) on all levels must have the same sequence.
						return nodesChanged(a.children,n.children)

						function nodesChanged(aL,nL) {
//							console.debug( 'nodesChanged',aL,nL )
							if( (!aL || aL.length<1) && (!nL || nL.length<1) ) return false;	// no update needed
							if( aL.length!=nL.length ) return true;								// update!
							for( let i=nL.length-1; i>-1; i-- ) {
								// compare the references only, as the hierarchy ids can change:
								if( !aL[i] || aL[i].ref!=nL[i].ref ) return true;
								if( nodesChanged(aL[i].children,nL[i].children) ) return true
							}; 
							return false
						}
					}
					
				// Note: 'updateTreeIfChanged' is called for instance of ALL types, even though only a hierarchy has children.
				// In case of an object or relation, the tree operations are skipped:
				if( ctg == 'hierarchy' && treeChanged(aI,nI) ) {
					message.show( i18n.MsgOutlineAdded, {severity:'info', duration:CONFIG.messageDisplayTimeShort} );
//					self.deleteContent('hierarchy',aI.children);		// can be be prohibited by removing the permission, but it is easily forgotten to change the role ...
					newIds(nI);
					server.project(myProject).specification(nI).createChildren()
						.done( function() {
							if( --pend<1 ) updateNext( ctg )
						})
						.fail( uDO.reject )
				} else {
					// no hierarchy (tree) has been changed, so no update:
					if( --pend<1 ) updateNext( ctg )
				}
			}
		}
	};

	self.createContent = function( ctg, item ) {  
		// item can be a js-object or a list of js-objects
		// ctg is a member of [dataType, objectType, relationType, hierarchyType, property class, object, relation, hierarchy]
		// ...  not all of them may be implemented, so far.
		// cache the value before sending it to the server, as the result is not received after sending (except for 'resource' and 'statement')

		switch( ctg ) {
			case 'node':
				return null;  // not supported
		//	case 'resource':
		//	case 'statement':
		//	case 'hierarchy':
				// add the baseType to property values to simplify the transformation for storing:
			//	addBaseTypes( item );
				// no break
			default:
				// if current user can create an item, he has the other permissions, as well:
			//	addPermissions( item );
				item.createdAt = new Date().toISOString();
				item.createdBy = item.changedBy;
				cache( ctg, item )
		};
		var sDO = $.Deferred();
		sDO.resolve({status:0});
		return sDO
	}; */
	self.readContent = function( ctg, item, opts ) {  
		// ctg is a member of [dataType, objectType, relationType, hierarchyType, object, relation, hierarchy]
		//  for compatibility with older callers:
	/*	if( typeof(opts)=='boolean' )
			opts = {reload: opts};
		// .. and by default:
		if( !opts )
			opts = {reload: false}; */
		
	//	if( !opts.reload ) {
			// Try to read from cache:
			var dO = readCache( ctg, item, false );
			if( dO ) return dO;
	//	};
		return null
	};
/*	self.updateContent = function( ctg, item ) {  
		// ctg is a member of [object, relation, hierarchy], 'null' is returned in all other cases.
		// (server does not allow type updates, so far.)

		switch( ctg ) {
			case 'node':	// nodes can only be created or deleted
				return null;  // not supported
		//	case 'resource':
		//	case 'statement':
		//	case 'hierarchy':
				// add the baseType to property values to simplify the transformation for storing:
			//	addBaseTypes( item );
				// no break
			default:
//				console.debug('updateContent - cache', ctg );
				item.changedAt = new Date().toISOString();
				item.changedBy = me.userName;
				cache( ctg, item )
		};
		var uDO = $.Deferred();
		uDO.resolve({status:0});
		return uDO
	};
	self.deleteContent = function( ctg, item ) {  
		// ctg is a member of [dataType, objectType, relationType, hierarchyType, property class, object, relation, hierarchy]
			function isInUse( ctg, itm ) {
					function dTIsInUse( L, dT ) {
						let i=null;
						for( var e=L.length-1;e>-1;e-- ) {
							i = L[e].propertyClasses?indexBy(L[e].propertyClasses,'dataType',dT.id):-1;
//							console.debug('dTIsInUse',dT,L,e,i); 
							if( i>-1 ) return true
						};
						return false
					}
					function sTIsInUse( ctg, sT ) {
						let c = ctg.substr(0,ctg.length-4),
							L = cacheOf(c),	// xyzType --> xyz
							i = indexBy(L,ctg,sT.id);
//						console.debug('sTIsInUse',sT,c,L,i); 
						// Problem: In project.html, the object cache is empty, but the objectType may be in use, anyways.
						// Similarly with statements and hierarchies.
						return ( i>-1 )
					}
					function aTIsInUse( L, pT ) {
						if( L==undefined ) return false; // can't be in use, if the list is not (yet) defined/present.
						let i=null;
						// Problem: In project.html, the object cache is empty, but the property class may be in use, anyways.
						// Also a deleted object may have used the property class.
						// As it stores only the newest types, the ReqIF Server will refuse to delete the type.
						// In case of PouchDB, all revisions of classes/types are stored, so it is sufficient to check whether there are currently some elements using the type.
						// Similarly with statements and hierarchies.
						for( var e=L.length-1;e>-1;e-- ) {
							i = L[e].properties?indexBy(L[e].properties,'class',pT.id):-1;
//							console.debug('aTIsInUse property class',pT,L,e,i); 
							if( i>-1 ) return true
						};
						return false
					}
//				console.debug('isInUse',ctg,item);
				switch( ctg ) {
					case 'dataType':		return dTIsInUse(self.allClasses,itm);
					case 'resourceClass':
					case 'statementClass':
					case 'hierarchyClass':	return sTIsInUse(ctg,itm);
					case 'class':	return aTIsInUse(self.resources,itm)
												|| aTIsInUse(self.hierarchies,itm)
												|| aTIsInUse(self.statements,itm) 
				};
				return false
			}
		
//		console.debug('deleteContent',ctg,item);
		var dDO = $.Deferred();
		// Do not try to delete types which are in use;
		// the ReqIF Server checks it, but the caching mechanism doesn't:
		switch( ctg ) {
			case 'node':
				return null;  // not supported
			case 'class':	
			case 'dataType':
			case 'resourceClass':
			case 'statementClass':
			case 'hierarchyClass':	if( Array.isArray(item) ) return null;	// not yet supported
									if( isInUse(ctg,item) ) {
										dDO.reject({status:972, statusText:i18n.Err400TypeIsInUse});
										return dDO
									};
									// no break;
			default: 				uncache( ctg, item );
		};
		dDO.resolve({status:0});
		return dDO
	};
	self.createNode = function( el ) {
		// creating a node is updating the hierarchy:
		var cPr = $.Deferred();
		let sId = self.selectedHierarchy.id, // memorize
			nI; 
		// 1. reload hierarchy to minimize update conflict,
		//    just specify the id to obtain the last revision:
	//	self.readContent( 'hierarchy', {id:self.selectedHierarchy.id}, {reload: true} )
	//		.done( function( nH ) {
//				console.debug('createNode current hierarchy',nH,el);
	//			cache( 'hierarchy', nH );
	//			self.selectedHierarchy = itemById( self.hierarchies, sId ) // update address
//				console.debug('createNode selected hierarchy',sId,self.selectedHierarchy);
				// 2. insert the node:
				nI = cache( 'node', el );
//				console.debug('createNode updated hierarchy',nI,self.selectedHierarchy);
				if( typeof(nI)=='number' && nI>-1 ) 
					// 3. update the hierarchy:
					self.updateContent( 'hierarchy', self.selectedHierarchy )
						.done( cPr.resolve )
						.fail( cPr.reject )
	//		})
	//		.fail( cPr.reject )
		return cPr
	};
	self.moveNode = function( el ) {
	};
	self.deleteNode = function( el ) {
		// deleting a node is updating a hierarchy:
		var dPr = $.Deferred();
		let sId = self.selectedHierarchy.id; // memorize
		let nI
		// 1. reload hierarchy to minimize update conflict,
		//    just specify the id to obtain the last revision:
	//	self.readContent( 'hierarchy', {id:self.selectedHierarchy.id}, {reload: true} )
	//		.done( function( nH ) {
//				console.debug('deleteNode current hierarchy',nH,el);
	//			cache( 'hierarchy', nH );
	//			myProject.selectedHierarchy = itemById( self.hierarchies, sId ) // update address
//				console.debug('deleteNode selected hierarchy',sId,self.selectedHierarchy);
				// 2. delete the node:
				nI = uncache( 'node', el );
//				console.debug('deleteNode updated hierarchy',nI,self.selectedHierarchy);
				if( nI ) 
					// 3. update the hierarchy:
					self.updateContent( 'hierarchy', self.selectedHierarchy )
						.done( dPr.resolve )
						.fail( dPr.reject )
	//		})
	//		.fail( dPr.reject )
		return dPr
	};

	self.initResource = function( oT ) { 
		// Create an empty form (resource instance) for the resource class oT:
		var fDO = $.Deferred();
//		console.debug( 'initResource', oT );

		// Get the class's permissions. So far, it's property permissions are not loaded ...
		self.readContent( 'resourceClass', oT, {reload:true} )
			.done( function(dta) {
				// return an empty resource instance of the given type: 
				var res = 
					{ class: dta.id,
					title: '',
					upd: true,
					properties: [] };
				dta.propertyClasses.forEach( function(pC) {
					if( pC.cre )
						res.properties.push( initPropC(pC) )
				});
//				console.debug('fillObject',res);
				if( res.properties.length ) 
					fDO.resolve( res )
				else
					fDO.reject({status:977, statusText:i18n.ErrInconsistentPermissions})
			})
			.fail( fDO.reject );
		return fDO
	};*/
	self.readStatementsOf = function( res, showComments ) {  
		// Get the statements of a resource ... there are 2 use-cases:
		// - All statements between resources appearing in a hierarchy shall be shown for navigation;
		//   it is possible that an object is deleted (from all hierarchies), but not it's statements.
		//   --> set 'showComments' to false
		// - All comments referring to the selected object shall be shown;
		//   the object is found in the cache, but the comment is not.
		//   --> set 'showComments' to true
		
			function isReferenced( rId ) {
				for( var s=self.hierarchies.length-1; s>-1; s-- )
					if( self.hierarchies[s].flatL.indexOf( rId )>-1 ) return true;
				return false
			}
		var sDO = $.Deferred();

		var rsp = myProject.statements.filter( function(s){ 
								// filter all statements involving res as subject or object:
								return ( res.id==s.subject.id || res.id==s.object.id )
								// AND fulfilling certain conditions:
									&&  ( 	
											// related subject and object must be referenced in the tree to be navigable,
											// also, the statement must not be declared 'hidden':
											!showComments
												&&	isReferenced( s.subject.id )
												&&	isReferenced( s.object.id )
												&&	s.title!=CONFIG.relTypeCommentRefersTo
												&& 	CONFIG.hiddenRelations.indexOf( s.title )<0
											// In case of a comment, the comment itself is not referenced, but the object:
										||	showComments
												&&	isReferenced( s.object.id )
												&&	s.title==CONFIG.relTypeCommentRefersTo
										)
							});
		sDO.resolve(rsp);
		return sDO
	};
/*	self.startAutoLoad = function( cb ) {
//		if( !self.cacheInstances ) return;
//		console.info( 'startAutoLoad' );
		if( typeof(cb)=="function" ) { autoLoadCb = cb };
		autoLoadId = genID( 'aU-' );
		// get all resources from the server to fill the cache:
		setTimeout( function() { autoLoad(autoLoadId) }, 600 )  // start a little later ...			
	};
	self.stopAutoLoad = function() {
//		console.info('stopAutoLoad');
		autoLoadId = null;
		loading = false
	};  
	self.loadInstances = function( cb ) {
		// for the time being - until the synchronizing will be implemented:
//		if( !self.cacheInstances ) return;
		// load the instances of the selected hierarchy (spec) into the cache (but not the types):
//		console.debug( 'self.loadInstances', self.selectedHierarchy, cb );
		if( self.selectedHierarchy ) {
			loading = true;  
			// update all resources referenced by the selectedHierarchy:
			loadObjsOf( self.selectedHierarchy )
				.done( function() {			
//					loadRelsOf( self.selectedHierarchy );
					// update the hierarchy (outline).
					// it is done after the resources to reflect any change in the hierarchy made during the loading.
					self.readContent( 'hierarchy', self.selectedHierarchy, true )	// true: reload
						// - call cb to refresh the app:
						.done( function() { 
							if( typeof(cb)=="function" ) cb();
							loading = false
						})
						.fail( function(xhr) { 
							loading = false
						})
				})
				.fail( function(xhr) { 
					loading = false
				})
		}
	};
	self.load = function(opts) {
		var lDO = $.Deferred();

		// load referenced resources and statements ... 
		if( opts.loadObjects ) {
			if( opts.loadAllSpecs ) 
				loadAll( 'resource' )
					.done( function() { 
						if( opts.loadRelations )
							return loadAll( 'statement' )
								.done( lDO.resolve )
								.fail( lDO.reject );
						// else
						lDO.resolve()
					})
					.fail( lDo.reject )
			else					
				loadObjsOf( self.selectedHierarchy )
					.done( function() { 
						if( opts.loadRelations )
							return loadRelsOf( self.selectedHierarchy )
								.done( lDO.resolve )
								.fail( lDO.reject );
						// else
						lDO.resolve()
					})
					.fail( lDo.reject );
			return
		} else {
			lDO.resolve()
		};
		return lDO
	};
*/
	self.export = function() {
			function handleError(xhr) {
				self.exporting = false;
				message.show( xhr )
			}  
		if( self.exporting ) return;
		let dlg = new BootstrapDialog({
			title: i18n.LblExport+": '"+self.title+"'",
			type: 'type-default',
			message: function (thisDlg) {
				var form = $('<form id="exportFmt" role="form" class="form-horizontal" ></form>');
				form.append( 
					$(	"<p>"+i18n.MsgExport+"</p>" +
						radioInput( i18n.LblFormat, [
							{title: 'SpecIF', description:''},
							{title: 'ReqIF', description:''},
							{title: 'ePub', description:''},
							{title: 'MS WORD (Open XML)', description:''}
						]) 
					) 
				);
				return form },
			buttons: [
				{ 	label: i18n.BtnCancel,
					action: function(thisDlg){ 
						thisDlg.close() 
					}
				},
				{ 	label: i18n.BtnExport,
					cssClass: 'btn-success', 
					action: function (thisDlg) {
						// Get index of option:
						let idx = radioValue( i18n.LblFormat );
						busy.set( true );
						switch(idx) {
							case '0':
								// export as SpecIF:
								self.exportAs( {format:'SpecIF'} )
									.done( function() { 
										message.show( "OK (200): "+i18n.MsgBrowserSaving, {severity:'success', duration:CONFIG.messageDisplayTimeShort} );
										busy.reset();
									})
									.fail( handleError );
								break;
							case '1':
								// export as ReqIF:
								console.info('Export as ReqIF not yet implemented');
								message.show( 'Export as ReqIF not yet implemented', {duration:CONFIG.messageDisplayTimeShort} );
								busy.reset();
								break;
							case '2':
								// export as ePub:
								self.exportAs( {format:'ePub'} )
									.done( function() { 
										message.show( "OK (200): "+i18n.MsgBrowserSaving, {severity:'success', duration:CONFIG.messageDisplayTimeShort} );
										busy.reset();
									})
									.fail( handleError );
								break;
							case '3':
								// export as OXML:
								self.exportAs( {format:'OXML'} )
									.done( function() { 
										message.show( "OK (200): "+i18n.MsgBrowserSaving, {severity:'success', duration:CONFIG.messageDisplayTimeShort} );
										busy.reset();
									})
									.fail( handleError )
						};
//						busy.reset();
						thisDlg.close()
					}
				}
			]
		})
		.open()
	};
	self.exportAs = function(opts) {
		if( self.exporting ) return null;
		
		if( !opts ) opts = {};
		if( !opts.format ) opts.format = 'SpecIF';
		// in certain cases, try to export files with the same name in PNG format, as well.
		// - ole: often, preview images are supplied in PNG format;
		// - svg: for generation of DOC or ePub, equivalent images in PNG-format are needed.
		if( !opts.alternatePngFor ) opts.alternatePngFor = ['svg','ole'];	
		
		var eDO = $.Deferred();

		/*	function handleError(xhr) {
				self.exporting = false; 
				eDO.reject(xhr)
			}  */
		
		if( self.exp ) {
			self.exporting = true;
			// reload the project from the server; the value is collected in myProject:
		/*	self.readContent( 'hierarchy', self.hierarchies, true )	// reload the hierarchies
				.done( function() { 	
					loadFiles()	// reload the files
						.done( function() { 	
							// load referenced resources and statements ... 
							loadAll( 'resource' )
								.done( function() { 
									loadAll( 'statement' )
										.done( function() { */
											// export the project to file:
											switch( opts.format ) {
												case 'SpecIF':
													storeSpecifz();
													break;
												case 'ePub':
													storeEpub()  
													break;
												case 'OXML':
													storeOxml()  
											}
		/*								})
										.fail( handleError )
								})
								.fail( handleError )
						})
						.fail( handleError )
				})
				.fail( handleError )  */
		} else {
			eDO.reject({status: 999, statusText: "No permission to export"})
		};
		return eDO

		function storeEpub( opts ) {
			if( !opts || typeof(opts.translateTitles)!='boolean' ) opts = {translateTitles: true};
			var data = self.get( opts );
//			console.debug( "exportAs 'ePub'", data );
			let options = { 
				// If the property titles are translated, then the lists declaring the semantics must, as well:
				headingProperties: opts.translateTitles? forAll( CONFIG.headingAttributes, i18n.lookup ) : CONFIG.headingAttributes,
				titleProperties: opts.translateTitles? forAll( CONFIG.titleAttributes, i18n.lookup ) : CONFIG.titleAttributes,
				descriptionProperties: opts.translateTitles? forAll( CONFIG.descriptionAttributes, i18n.lookup ) : CONFIG.descriptionAttributes,
				// Values of declared stereotypeProperties get enclosed by double-angle quotation mark '&#x00ab;' and '&#x00bb;'
				stereotypeProperties: opts.translateTitles? forAll(CONFIG.stereotypeAttributes, i18n.lookup ) : CONFIG.stereotypeAttributes,
				// If a hidden property is defined with value, it is suppressed only if it has this value;
				// if the value is undefined, the property is suppressed in all cases.
				// so far (iLaH v0.92.44), property titles are translated:
				hiddenProperties: opts.translateTitles? [{title:i18n.lookup('SpecIF:Type'),value:'SpecIF:Folder'}] : [{title:'SpecIF:Type',value:'SpecIF:Folder'}],
				hideEmptyProperties: true,
				propertiesLabel: opts.translateTitles? i18n.lookup('SpecIF:Properties') : 'SpecIF:Properties',
				statementsLabel: opts.translateTitles? i18n.lookup('SpecIF:Statements') : 'SpecIF:Statements',
				done: function() { myProject.exporting=false; eDO.resolve() },
				fail: function(xhr) { myProject.exporting=false; eDO.reject(xhr) }
			};
//			console.debug('storeEpub',data,options);
			toEpub( data, options )
		}
		function storeOxml( opts ) {
			if( !opts || typeof(opts.translateTitles)!='boolean' ) opts = {translateTitles: true};
			var data = self.get( opts );
//			console.debug( "exportAs 'ePub'", data );
			let options = { 
				// If the property titles are translated, then the lists declaring the semantics must, as well:
				headingProperties: opts.translateTitles? forAll( CONFIG.headingAttributes, i18n.lookup ) : CONFIG.headingAttributes,
				titleProperties: opts.translateTitles? forAll( CONFIG.titleAttributes, i18n.lookup ) : CONFIG.titleAttributes,
				descriptionProperties: opts.translateTitles? forAll( CONFIG.descriptionAttributes, i18n.lookup ) : CONFIG.descriptionAttributes,
				// Values of declared stereotypeProperties get enclosed by double-angle quotation mark '&#x00ab;' and '&#x00bb;'
				stereotypeProperties: opts.translateTitles? forAll(CONFIG.stereotypeAttributes, i18n.lookup ) : CONFIG.stereotypeAttributes,
				// If a hidden property is defined with value, it is suppressed only if it has this value;
				// if the value is undefined, the property is suppressed in all cases.
				// so far (iLaH v0.92.44), property titles are translated:
				hiddenProperties: opts.translateTitles? [{title:i18n.lookup('SpecIF:Type'),value:'SpecIF:Folder'}] : [{title:'SpecIF:Type',value:'SpecIF:Folder'}],
				hideEmptyProperties: true,
				propertiesLabel: opts.translateTitles? i18n.lookup('SpecIF:Properties') : 'SpecIF:Properties',
				statementsLabel: opts.translateTitles? i18n.lookup('SpecIF:Statements') : 'SpecIF:Statements',
				done: function() { myProject.exporting=false; eDO.resolve() },
				fail: function(xhr) { myProject.exporting=false; eDO.reject(xhr) }
			};
//			console.debug('storeOxml',data,options);
			toOxml( data, options )
		}
		function storeSpecifz() {
			let zip = new JSZip(),
				data = self.get( {translateTitles: false} );
//			console.debug( "exportAs 'SpecIF'", data );
			let blob = new Blob([JSON.stringify( data )], {type: "text/plain; charset=utf-8"});
			// Add the project:
			zip.file( data.title+".specif", blob );
			blob = null; // free heap space
			
			// Add the files and save all, when done:
//			console.debug('files',data.files);
			data.files.forEach( function(f) {
				zip.file( f.id, f.blob )
			});
			
			// done, store the specifz:
			zip.generateAsync({
					type: "blob"
				})
				.then(
					function(blob) {
//						console.debug("storing ",data.title+".specifz");
						saveAs(blob, data.title+".specifz");
						self.exporting = false;
						eDO.resolve()
				}, 
					function(xhr) {
						console.error("Cannot store ",data.title+".specifz");
						self.exporting = false;
						eDO.reject()
				})
		}
	};
	self.set = function( spD ) {
		// transform SpecIF to internal data;
		// no data of myProject is modified.
		// It is assumed that spD has passed the schema and consistency check.
//		console.debug('set',spD);
		let names = {};
		switch( spD.specifVersion ) {
			case '0.10.2':
			case '0.10.3':
				names.rClasses = 'resourceTypes';
				names.sClasses = 'statementTypes';
				names.hClasses = 'hierarchyTypes';
				names.pClasses = 'propertyTypes';
				names.subClasses = 'subjectTypes';
				names.objClasses = 'objectTypes';
				names.rClass = 'resourceType';				
				names.sClass = 'statementType';
				names.hClass = 'hierarchyType';
				names.pClass = 'propertyType';
				break;
			default:
				names.rClasses = 'resourceClasses';
				names.sClasses = 'statementClasses';
				names.hClasses = 'hierarchyClasses';
				names.pClasses = 'propertyClasses';
				names.subClasses = 'subjectClasses';
				names.objClasses = 'objectClasses';
				names.rClass = 'class';
				names.sClass = 'class';
				names.hClass = 'class';
				names.pClass = 'class'
		};
		
		try {
			var iD = {
				dataTypes: 			forAll( spD.dataTypes, dT2int )
			};
			iD.propertyClasses = 	forAll( spD.propertyClasses, pC2int );	// starting v0.10.6
			iD.resourceClasses = 	forAll( spD[names.rClasses], rC2int );
			iD.statementClasses =	forAll( spD[names.sClasses], sC2int );
			iD.hierarchyClasses =	forAll( spD[names.hClasses], hC2int );
			iD.resources = 			forAll( spD.resources, r2int );
			iD.statements =			forAll( spD.statements, s2int );
			iD.hierarchies =		forAll( spD.hierarchies, h2int );
			iD.files =				forAll( spD.files, f2int )
		} catch (e) {
			console.error( "Error when importing the project '"+spD.title+"'" );
			message.show( i18n.phrase( 'MsgImportFailed', spD.title ), {severity:'danger'} );
			return null
		};
		
		// header information provided only in case of project creation, but not in case of project update:
		if( spD.id ) iD.id = spD.id;
		if( spD.title ) iD.title = spD.title;
		if( spD.description ) iD.description = spD.description;
		if( spD.generator ) iD.generator = spD.generator;
		if( spD.generatorVersion ) iD.generatorVersion = spD.generatorVersion;
		if( spD.createdBy ) iD.createdBy = spD.createdBy;
		if( spD.createdAt ) iD.createdAt = spD.createdAt;
		
//		console.debug('specif.set',iD);
		return iD

			function dT2int( iE ) {
		//		iE.category = 'dataType';
				switch( iE.type ) {
					case "xhtml": 
					case "xs:string":		
						if( typeof(iE.maxLength)!='number' ) iE.maxLength = CONFIG.maxStringLength;
				//		break;
				//	case "xs:enumeration": 	
				//		if( !iE.values ) iE.values = [];
				};
//				console.debug('dataType 2int',iE);
				return iE
			}
			function pC2int( iE ) {
				var oE = {
					id: iE.id,
					title: vocabulary.property.specif(noCode(iE.title))	// an input file may have titles which are not from the SpecIF vocabulary.
				};
				if( iE.description ) oE.description = noCode(iE.description);
				oE.dataType = iE.dataType;
				let dT = itemById( iD.dataTypes, iE.dataType );
				switch( dT.type ) {
					case 'xs:enumeration': 
						// include the property only, if is different from the dataType's:
						if( iE.multiple && !dT.multiple ) oE.multiple = true
						else if( iE.multiple==false && dT.multiple ) oE.multiple = false
				};
				if( iE.revision ) oE.revision = iE.revision;
				oE.changedAt = iE.changedAt;
				if( iE.changedBy ) oE.changedBy = iE.changedBy;
		//		if( iE.createdAt ) oE.createdAt = iE.createdAt;
		//		if( iE.createdBy ) oE.createdBy = iE.createdBy;
//				console.debug('propClass 2int',iE,oE);
				return oE
			}
			// common for all classes:
			function aC2int( iE ) {
				var oE = {
					id: iE.id,
					title: vocabulary.resource.specif(noCode(iE.title))
				};
				if( iE.description ) oE.description = noCode(iE.description);
				if( iE.icon ) oE.icon = iE.icon;
				if( iE.creation ) oE.instantiation = iE.creation;	// deprecated, for compatibility
				if( iE.instantiation ) oE.instantiation = iE.instantiation;
				if( oE.instantiation ) 	{
					let idx = oE.instantiation.indexOf('manual');	// deprecated
					if( idx>-1 ) oE.instantiation.splice(idx,1,'user')
				};	
				// Up until v0.10.5, the pClasses themself are listed, starting v0.10.6 their ids are listed as a string.
				if( Array.isArray(iE[names.pClasses]) && iE[names.pClasses].length>0 )
					if( typeof(iE[names.pClasses][0])=='string' )
						// copy the list of pClasses' ids:
						oE.propertyClasses = iE.propertyClasses
					else {
						// internally, the pClasses are stored like in v0.10.6.
						oE.propertyClasses = [];
						iE[names.pClasses].forEach( function(e) {
							// Store the pClasses at the top level:
							iD.propertyClasses.push(pC2int(e));
							// Add to a list with pClass' ids, here:
							oE.propertyClasses.push(e.id)
						})
					}
				else
					oE.propertyClasses = [];
				
				if( iE.revision ) oE.revision = iE.revision;
				oE.changedAt = iE.changedAt;
				if( iE.changedBy ) oE.changedBy = iE.changedBy;
		//		if( iE.createdAt ) oE.createdAt = iE.createdAt;
		//		if( iE.createdBy ) oE.createdBy = iE.createdBy;
//				console.debug('anyClass 2int',iE,oE);
				return oE
			}
			function rC2int( iE ) {
				var oE = aC2int( iE );
		//		oE.category = 'resourceClass';

				// If "iE.isHeading" is defined, use it:
				if( typeof(iE.isHeading)=='boolean' ) {
					oE.isHeading = iE.isHeading;
					return oE
				};
				// else: take care of older data without "isHeading":
				if( iE.title=='SpecIF:Heading' ) {
					oE.isHeading = true;
					return oE
				};
				// else: look for a property class being configured in CONFIG.headingAttributes
				oE.isHeading = false;
				let pC;
				for( var a=oE.propertyClasses.length-1;a>-1;a-- ) {
					pC = oE.propertyClasses[a];
					// look up propertyClass starting v0.101.6:
					if( typeof(pC)=='string' ) pC = itemById(iD.propertyClasses, pC);
					if( CONFIG.headingAttributes.indexOf( pC.title )>-1 ) {
						oE.isHeading = true;
						break
					}
				};
//				console.debug('resourceClass 2int',iE,oE);
				return oE
			}
			function sC2int( iE ) {
				var oE = aC2int( iE );
		//		oE.category = 'statementClass';
				if( iE[names.subClasses] ) oE.subjectClasses = iE[names.subClasses];
				if( iE[names.objClasses] ) oE.objectClasses = iE[names.objClasses];
//				console.debug('statementClass 2int',iE,oE);
				return oE
			}
			function hC2int( iE ) {
				var oE = aC2int( iE );
		//		oE.category = 'hierarchyClass';
//				console.debug('hierarchyClass 2int',iE,oE);
				return oE
			}
			function p2int( iE ) {
				let pT = itemById( iD.propertyClasses, iE[names.pClass] ),
					dT = itemById( iD.dataTypes, pT.dataType );
				var oE = {
					// no id
					title: vocabulary.property.specif(noCode(iE.title || pT.title))	// an input file may have titles which are not from the SpecIF vocabulary.
				};
				oE['class'] = iE[names.pClass];
				if( iE.description ) oE.description = noCode(iE.description);
				switch( dT.type ) {
					case 'xs.boolean':
						oE.value = iE.value=='true';
						break;
					case 'xs.integer':
						oE.value = parseInt(iE.value,10);
						break;
					case 'xs.double':
						oE.value = parseFloat(iE.value);
						break;
					default:
						oE.value = noCode(iE.value)
				};
				// sub-elements do not have their own revision and change info
//				console.debug('propValue 2int',iE,pT,oE);
				return oE
			}
			function a2int( iE ) {
				var oE = {
					id: iE.id,
					title: noCode(iE.title)
				};
				if( iE.description ) oE.description = noCode(iE.description);
				oE.properties = forAll( iE.properties, p2int );

				if( iE.revision ) oE.revision = iE.revision;
				oE.changedAt = iE.changedAt;
				if( iE.changedBy ) oE.changedBy = iE.changedBy;
	//			if( iE.createdAt ) oE.createdAt = iE.createdAt;
	//			if( iE.createdBy ) oE.createdBy = iE.createdBy;
//				console.debug('element 2int',oE);
				return oE
			}
			function r2int( eR ) {
				var iR = a2int( eR );
				iR['class'] = eR[names.rClass];
//				console.debug('resource 2int',eR,iR);
				return iR
			}
			function s2int( eS ) {
				var iS = a2int( eS );
				iS.title = itemById( iD.statementClasses, eS[names.sClass] ).title;
				iS['class'] = eS[names.sClass];
				// SpecIF allows subjects and objects with id (v0.10.2) or with id+revision (v0.11.1),
				// so normalize internally to id+revision:
				switch( typeof(eS.subject) ) {
					case "object": iS.subject = eS.subject; break;				// eS is SpecIF 0.11.1
					case "string": iS.subject = {id: eS.subject, revision: 0}	// eS is SpecIF 0.10.2
				};
				switch( typeof(eS.object) ) {
					case "object": iS.object = eS.object; break;			
					case "string": iS.object = {id: eS.object, revision: 0} 
				};
//				console.debug('statement 2int',eS,iS);
				return iS
			}
			function h2int( eH ) {
				var iH = a2int( eH );
				iH['class'] = eH[names.hClass];
				// list all resource ids in a flat list:
				iH.flatL = [];
				iH.nodes = forAll( eH.nodes, n2int );
//				console.debug('hierarchy 2int',eH,iH);
				return iH

				function n2int( eN ) {
					iH.flatL.push(eN.resource);
					forAll( eN.nodes, n2int );
					return eN
				}
			}
			function f2int( eF ) {
				var iF = eF;
				if( eF.blob ) iF.type = eF.blob.type || eF.type || attachment2mediaType( eF.id );
				if( eF.revision ) iF.revision = eF.revision;
				iF.changedAt = eF.changedAt;
				if( eF.changedBy ) iF.changedBy = eF.changedBy;
		//		if( eF.createdAt ) iF.createdAt = eF.createdAt;
		//		if( eF.createdBy ) iF.createdBy = eF.createdBy;
//				console.debug('file 2int',eF,iF);
				return iF
			}
	};
	self.get = function( opts ) {
		// transform the current content of prj (in internal data format) to SpecIF
		if( opts ) {
			if( typeof(opts.translateTitles)!='boolean' ) 
				opts.translateTitles = false
		} else {
			opts = {
				translateTitles: false
			}
		};
		
		// transform internal data to SpecIF:
		var spD = {
				id: myProject.id,
				title: myProject.title
			};
		if( myProject.description ) spD.description = myProject.description;
		spD.specifVersion = CONFIG.specifVersion;
		spD.generator = CONFIG.productTitle;
		spD.generatorVersion = CONFIG.productVersion;
		spD.rights = {
			title: "Creative Commons 4.0 CC BY-SA",
			type: "dcterms:rights",
			url: "https://creativecommons.org/licenses/by-sa/4.0/"
		};
		spD.createdAt = new Date().toISOString();
		// createdBy.email is required by the schema:
		if( me && me.email ) {
			spD.createdBy = {
				familyName: me.lastName, 
				givenName: me.firstName, 
				email: {type:"text/html",value:me.email}
			};
			if( me.organization )
				spD.createdBy.org = {organizationName: me.organization}
		} else {
			if( myProject.createdBy && myProject.createdBy.email && myProject.createdBy.email.value )  {
				spD.createdBy = { 
					familyName: myProject.createdBy.familyName, 
					givenName: myProject.createdBy.givenName, 
					email: {type:"text/html",value:myProject.createdBy.email.value}
				};
				if( myProject.createdBy.org && myProject.createdBy.org.organizationName )
					spD.createdBy.org = myProject.createdBy.org
			}
			// else: no createdBy, if there is no data 
		};
		spD.dataTypes = forAll( myProject.dataTypes, dT2ext );
		spD.propertyClasses = forAll( myProject.propertyClasses, pC2ext );
		spD.resourceClasses = forAll( myProject.resourceClasses, rC2ext );
		spD.statementClasses = forAll( myProject.statementClasses, sC2ext );
		spD.hierarchyClasses = forAll( myProject.hierarchyClasses, hC2ext );
		spD.resources = forAll( myProject.resources, r2ext );
		spD.statements = forAll( myProject.statements, s2ext );
		spD.hierarchies = forAll( myProject.hierarchies, h2ext );
		spD.files = forAll( myProject.files, f2ext );
		// ToDo: schema and consistency check (if we want to detect any programming errors)
//		console.debug('specif.get done',spD);
		return spD

			function dT2ext( iE ) {
				var oE = simpleClone(iE);
		//		delete oE.category;
				return oE
			}
			function pC2ext( iE ) {
				var oE = {
					id: iE.id,
					title: opts.translateTitles? titleOf(iE) : iE.title		
				};
				if( iE.description ) oE.description = iE.description;
				oE.dataType = iE.dataType;
				let dT = itemById( myProject.dataTypes, iE.dataType );
				switch( dT.type ) {
					case 'xs:enumeration': 
						// With SpecIF, he 'multiple' property should be defined at dataType level and can be overridden at propertyType level.
						// 	dT.multiple 	aTs.multiple 	aTs.multiple	effect
						// ---------------------------------------------------------
						//	undefined		undefined 		undefined		false
						//	false			undefined		undefined		false
						//	true			undefined		undefined		true
						//	undefined		false			undefined		false
						//	false			false			undefined		false
						//	true 			false			false			false
						//	undefined		true 			true			true
						//	false			true 			true			true
						//	true 			true 			undefined		true
						// Include the property only, if is different from the dataType's:
						if( iE.multiple && !dT.multiple ) oE.multiple = true
						else if( iE.multiple==false && dT.multiple ) oE.multiple = false
				};
				if( iE.revision ) oE.revision = iE.revision;
				oE.changedAt = iE.changedAt;
				if( iE.changedBy ) oE.changedBy = iE.changedBy;
	//			if( iE.createdAt ) oE.createdAt = iE.createdAt;
	//			if( iE.createdBy ) oE.createdBy = iE.createdBy;
				return oE
			}
			// common for all classes:
			function aC2ext( iE ) {
				var oE = {
					id: iE.id,
					title: opts.translateTitles? titleOf(iE) : iE.title	
				};
				if( iE.description ) oE.description = iE.description;
				if( iE.icon ) oE.icon = iE.icon;
				if( iE.instantiation ) oE.instantiation = iE.instantiation;
				if( iE.propertyClasses.length>0 ) oE.propertyClasses = iE.propertyClasses;
				if( iE.revision ) oE.revision = iE.revision;
				oE.changedAt = iE.changedAt;
				if( iE.changedBy ) oE.changedBy = iE.changedBy;
	//			if( iE.createdAt ) oE.createdAt = iE.createdAt;
	//			if( iE.createdBy ) oE.createdBy = iE.createdBy;
				return oE
			}
			function rC2ext( iE ) {
				var oE = aC2ext( iE );
				// Include "isHeading" in SpecIF only if true:
				if( iE.isHeading ) oE.isHeading = true;
				return oE
			}
			function sC2ext( iE ) {
				var oE = aC2ext( iE );
				if( iE.subjectClasses && iE.subjectClasses.length>0 ) oE.subjectClasses = iE.subjectClasses;
				if( iE.objectClasses && iE.objectClasses.length>0 ) oE.objectClasses = iE.objectClasses;
				return oE
			}
			function hC2ext( iE ) {
				var oE = aC2ext( iE );
				return oE
			}
			function p2ext( iE ) {
				if( !iE.value ) return null;	// skip empty properties
				var oE = {
					// no id
					// internally only valid SpecIF terms are used (hope so ;-)
					title: opts.translateTitles? titleOf(iE) : iE.title		
				};
				oE['class'] = iE['class'];
				if( iE.description ) oE.description = iE.description;
				
				// according to the schema, all property values are represented by a string:
				switch( typeof(iE.value) ) {
					case 'boolean':
						oE.value = bool.toString(iE.value);
						break;
					case 'number':
						oE.value = num.toString(iE.value);
						break;
					default:
						oE.value = iE.value
				};
				// properties do not have their own revision and change info; the parent's apply.
				return oE
			}
			function a2ext( iE ) {
				var eE = {
					id: iE.id,
					// resources and hierarchies usually have individual titles, and so we will not translate:
					title: resTitleOf( iE )
				};
				if( iE.description ) eE.description = iE.description;
				eE['class'] = iE['class'];
				let aL = forAll( iE.properties, p2ext );
				if( aL.length>0 ) eE.properties = aL;
				if( iE.revision ) eE.revision = iE.revision;
				eE.changedAt = iE.changedAt;
				if( iE.changedBy ) eE.changedBy = iE.changedBy;
	//			if( iE.createdAt ) eE.createdAt = iE.createdAt;
	//			if( iE.createdBy ) eE.createdBy = iE.createdBy;
				return eE
			}
			function r2ext( iR ) {
				var eR = a2ext( iR );
	//			console.debug('resource 2int',iR,eR);
				return eR
			}
			function s2ext( iS ) {
	//			console.debug('statement 2ext',iS.title);
				if( CONFIG.hiddenRelations.indexOf( iS.title )>-1 ) return null;  // do not export invisible statements
				var eS = a2ext( iS );
				// The statements usually do use a vocabulary item (and not have an individual title), 
				// so we translate, if so desired, e.g. when exporting to ePub:
				// ToDo: Take the title from statement properties, if provided (similarly to resources).
				// Take the statementClass's title, if the statement does not have it:
				iS.title = iS.title || itemById( myProject.statementClasses, iS['class'] ).title;
				eS.title = opts.translateTitles? titleOf(iS) : iS.title;
				eS.subject = iS.subject.id;
				eS.object = iS.object.id;
				return eS
			}
			function n2ext( iN ) {
				return iN
			}
			function h2ext( iH ) {
				var eH = a2ext( iH );
				eH.nodes = forAll( iH.nodes, n2ext );
	//			console.debug('hierarchy 2ext',iH,eH);
				return eH
			}
			function f2ext( iF ) {
				var eF = {
					id: iF.id,  // is the distinguishing/relative part of the URL
	//				title: ,
					type: iF.type
				};
				if( iF.blob ) eF.blob = iF.blob;
				if( iF.revision ) oE.revision = iF.revision;
				eF.changedAt = iF.changedAt;
				if( iF.changedBy ) eF.changedBy = iF.changedBy;
	//			if( iF.createdAt ) eF.createdAt = iF.createdAt;
	//			if( iF.createdBy ) eF.createdBy = iF.createdBy;
				return eF
			}
	};
	self.check = function( data ) {
		// Check the SpecIF data for schema compliance and consistency;
		// no data of myProject is modified:
		var cDO = $.Deferred();
		// 1. Validate the data using the SpecIF schema:
		cDO.notify('Checking schema',10);

		// Get the specified schema file from the server:
		httpGet({
			url: "https://specif.de/v"+data.specifVersion+"/schema", 
			responseType: 'arraybuffer',
			withCredentials: false,	
			done: function(xhr) { 
//				console.debug('schema', xhr);
						// 1. check data against schema:
						let rc = checkSchema( JSON.parse( buf2str(xhr.response) ), data );
						if( rc.status!=0 ) {
							// older versions of the checking routine don't set the responseType:
							if( typeof(rc.responseText)=='string' && rc.responseText.length>0 )
								rc.responseType = 'text';
							cDO.reject( rc ); 
							return 
						};

						// 2. Check further constraints:
						cDO.notify('Checking constraints',20);
						rc = checkConstraints( data );
						if( rc.status==0 ) {
							cDO.resolve( data, rc )
						} else {
							// older versions of the checking routine don't set the responseType:
							if( typeof(rc.responseText)=='string' && rc.responseText.length>0 )
								rc.responseType = 'text';
							console.error('SpecIF Consistency Check:', rc);
							cDO.reject( rc )
						}
			},	
			fail: function(xhr) { 
				switch( xhr.status ) {
					case 404:
						xhr = { status: 903, statusText: 'SpecIF version '+data.specifVersion+' is not supported by the program!' };
					default:
						cDO.reject(xhr)
				}
			} 
		//	then: 
		});
		return cDO
	};
	self.abort = function() {
		console.info('abort specif');
	//	server.abort();
		self.abortFlag = true
	};
	return self

//////////
// some local helper routines:

	function queryObjects( qu, reload ) {   
		// get all the resources of the specified type: qu is {type: class}
	//	if( !reload ) {
			// collect all resources with the queried type:
			var oL = forAll( self.resources, function(o) { return o['class']==qu.type?o:null } ),
				dO = $.Deferred();  
			dO.resolve( oL );
			return dO
	//	};
	}
/*	function loadFiles() {
		// in case of ReqIF Server, only a list of file meta data is delivered,
		// whereas in case of PouchDB, the files themselves are delivered.
		return self.readContent( 'file', 'all', {reload:true} )
	}
	function loadObjsOf( sp ) {
		// Cache all resources referenced in the given spec (hierarchy):
		if( !sp ) { sp = self.selectedHierarchy };
//		console.debug( 'loadObjsOf', sp );

		var cDO = $.Deferred();

			// is called recursively until the whole list has been processed:
			function loadObjs( oL ) {
				if( !loading && !self.exporting ) { return };  // in case the loading has been stopped (by stopAutoLoad) ...
				// convert list of hierarchy entries to list of resources:
				var rL=[];
				for( var o=oL.length-1;o>-1;o-- ) rL[o] = {id: oL[o]};  

				return server.readContent( 'resource', rL )
					.done(function(rsp) {
						// continue caching, if the project hasn't been left, meanwhile:
						if( sp ) {  // sp is null, if the project has been left.
							cacheL( self.resources, rsp );
					
							if( cI<sp.flatL.length ) {
								rL = sp.flatL.slice(cI,cI+CONFIG.objToGetCount),  // object list; slice just extracts and does not change original list
								cI += rL.length;  // current index
								loadObjs( rL );
								return
							} else {
								cDO.resolve( self.resources );
								return
							}
						}
					})
					.fail( cDO.reject )
			}
		if( sp && sp.flatL.length>0 ) {
			var rL = sp.flatL.slice(0,CONFIG.objToGetCount),  // object list; slice just extracts and does not change original list
				cI=rL.length;  // current index pointing to start of next batch
			loadObjs( rL )
		} else {
			cDO.resolve([])
		};
		return cDO
	}
	function loadRelsOf( sp ) {
		// Check all referenced resources and get their statements.  Cache the results.  
		// Not efficient, but effective and without alternative in light of the server API.
		if( !sp ) { sp = self.selectedHierarchy };
//		console.debug( 'loadRelsOf', sp );

		var rDO = $.Deferred();

			// is called recursively until the whole list has been processed:
			function loadRels( ob ) {
				if( !loading && !self.exporting ) { return };  // in case the loading has been stopped (by stopAutoLoad) ...
//				console.debug( 'loadRels', ob );
				self.readStatementsOf( ob )
					.done(function(rsp) {
						// continue caching, if the project hasn't been left, meanwhile (sp==null):
						if( sp && ++cI<sp.flatL.length ) {
							loadRels( {id:sp.flatL[cI]} )
						} else {
							rDO.resolve( self.statements )
						}
					})
					.fail( rDO.reject )
			}
		if( sp && sp.flatL.length && self.statementClasses.length>0 ) {
			var cI=0;  // current index
			loadRels( {id:sp.flatL[cI]} )
		} else {
			rDO.resolve([])
		};
		return rDO
	}
	function loadAll( ctg ) {
		// Cycle through all hierarchies and load the instances of the specified ctg:
		// The loaded data is cached.
		switch( ctg ) {
			case 'resource': 		var fn=loadObjsOf; break;
			case 'statement': 	var fn=loadRelsOf; break;
			default: return null
		};
		var dO = $.Deferred(),
			pend = self.hierarchies.length;
		for( var i=self.hierarchies.length-1; i>-1; i-- ) {
			fn( self.hierarchies[i] )
				.done(function() {
					if(--pend<1) dO.resolve()
				})
				.fail( dO.reject )
		};
		if( self.hierarchies.length<1 ) dO.resolve();
		return dO
	}
	function autoLoad( aU ) {
//		console.debug( 'cache.autoLoad', aU );
		// only update the cache and continue the chain, if autoLoadId of the time of execution is equal to the time of calling (aU):
		if( autoLoadId && aU==autoLoadId ) {
			// Start timer for next update:
			setTimeout( function() { autoLoad( aU ) }, CONFIG.cacheAutoLoadPeriod )
			
			// skip this turn, if autoLoad from last trigger is still being executed (avoid multiple updates in parallel):
			if( loading ) { console.info( 'Skipping autoLoad cycle' ); return };
			// else, start the update:
			loading = true;
			// 1) load the dataTypes:
			self.readContent( 'dataType', [], true )	// true: reload
				.done( function() {
					if( autoLoadId && aU==autoLoadId ) {  // if the update hasn't been stopped, meanwhile
						// 2) load allClasses:
						self.readContent( 'anyClass', [], true )
							.done( function() {
								// new allClasses and the permissions have arrived.
								// 3) update the current spec and the referenced resources:
								if( autoLoadId && aU==autoLoadId )   // if the update hasn't been stopped, meanwhile
									self.loadInstances( autoLoadCb )
							})
							.fail( function(xhr) { 
								loading = false	// e.g. when importing, the calls will fail, but thereafter the autoLoad shall resume.
							})
					}
				})
				.fail( function(xhr) { 
					loading = false	// e.g. when importing, the calls will fail, but thereafter the autoLoad shall resume.
				})
		}
		// else: project has been left or another autoLoad chain has been started, so break this chain.
	} 

	function addBaseTypes( item ) {
		if( !server || server.type=='PouchDB' ) return;
		// only needed for ReqIF Server:
		// add base types for easier (context-free) processing of properties when storing; 
		// for use with createContent and updateContent functions. 
		if( !item || Array.isArray(item)&&item.length<1 ) return;
			function addBT(itm) {
				if( !itm.properties || itm.properties.length<1 ) return;
				let sT = itemById( self.allClasses, itm['class'] ),pT=null,dT=null;
				for( var a=itm.properties.length-1; a>-1; a-- ) {
					pT = itemById( sT.propertyClasses, itm.properties[a].class );
					dT = itemById( self.dataTypes, pT.dataType );
					itm.properties[a].baseType = dT.type
				}
			}
		if( Array.isArray(item) )
			item.forEach( function(itm) {addBT(itm)} )
		else 
			addBT(item)
	}
	function addPermissions( item ) { 
		// add permissions; 
		// for use with createContent and updateContent functions. 
		// Take the correct permissions from the type:
		if( !item || Array.isArray(item)&&item.length<1 ) return;
			function addPerms( itm ) {
				// if current user can create an type, he has the other permissions, as well:
				itm.upd=true; 
				itm.del=true;
				if( itm.properties )
					itm.properties.forEach( function(ip) {
						ip.upd=true;
						ip.del=true
					})
			}
		if( Array.isArray(item) )
			item.forEach( function(itm) {addPerms(itm)} )
		else 
			addPerms(item)
	}  
*/
	function cache( ctg, item ) { 
		if( !item || Array.isArray(item)&&item.length<1 ) return;
		// If item is a list, all elements must have the same category.
		let fn = Array.isArray(item)?cacheL:cacheE;
		switch(ctg) {
			case 'hierarchy':
			case 'dataType':
			case 'propertyClass':		return fn( cacheOf(ctg), item );
			case 'resourceClass': 
			case 'statementClass': 
			case 'hierarchyClass': 		fn( self.allClasses, item); return fn( cacheOf(ctg), item );
			case 'class':				if(Array.isArray(item)||!item['class']) return null;  // cannot process arrays in this case, yet.
//										console.debug('cache class',item,itemById(self.allClasses,item['class'])); 
										return cacheAtPosition( itemById(self.allClasses,item['class']).propertyClasses, item ); ;
			case 'resource': 		
			case 'statement': 	
			case 'file': 				if(self.cacheInstances) return fn( cacheOf(ctg), item );
										else return;
			case 'node':				if(Array.isArray(item)||!item.parent) return null;
										self.selectedHierarchy.flatL.push( item.ref );
//										console.debug('cache',ctg,item);
										return cacheNode( item ); 
			default: return null
		}
	}
	function uncache( ctg, item ) { 
			function delNode( L, eId ) {
//				console.debug('delNode',L);
				for( var h=L.length-1;h>-1;h-- ) {
					if( L[h].id==eId ) {
						L.splice(h,1);
						return true
					};
					if( delNode( L[h].nodes, eId ) ) return true
				};
				return false
			}
		if( !item ) return;
		let fn = Array.isArray(item)?uncacheL:uncacheE;
		switch(ctg) {
			case 'hierarchy':		
			case 'dataType': 
			case 'propertyClass':		return fn( cacheOf(ctg), item );
			case 'resourceClass': 	
			case 'statementClass': 
			case 'hierarchyClass': 		fn( self.allClasses, item); return fn( cacheOf(ctg), item );
			case 'class':				let sT = itemById(self.allClasses,item['class']);
//										console.debug('uncache class',item,sT); 
										return fn( sT.propertyClasses, item );
			case 'resource': 	
			case 'statement': 			
			case 'file':				if(self.cacheInstances) return fn( cacheOf(ctg), item );
										else return;
			case 'node':				if( Array.isArray(item) ) return null;
										removeFromArray( self.selectedHierarchy.flatL, item.ref );
										return delNode( self.hierarchies, item.id );
			default: return null
		}
	}
	function cacheOf( ctg ) {
		// Return the cache for a given category:
		switch(ctg) {
			case 'dataType':		return self.dataTypes;
			case 'propertyClass':	return self.propertyClasses;
			case 'resourceClass':	return self.resourceClasses;
			case 'statementClass':	return self.statementClasses;
			case 'hierarchyClass':	return self.hierarchyClasses;
			case 'resource':		return self.resources;
			case 'statement':		return self.statements;
			case 'hierarchy':		return self.hierarchies;
			case 'file':			return self.files;
			default: return null
		}
	}
	function readCache( ctg, itm, reload ) {
		// Read an item from cache, unless 'reload' is specified:
		if( !reload ) {
			let arr = cacheOf(ctg),
				idx=null;
//			console.debug( 'readCache', arr );
			if( itm=='all' ) {
					// return all cached resources asynchronously:
					var dO = $.Deferred();  
//					console.debug( 'readCache', arr, itm );
					dO.resolve( [].concat(arr) );	// return a new list with the original elements
					return dO
			};
			if( Array.isArray(itm) ) {
				let allFound=true, i=0, I=itm.length;
				while( allFound && i<I ) {
					idx = indexById( arr, itm[i].id );
					if( idx>-1 )
						itm[i] = arr[idx]
					else
						allFound = false;
					i++
				};
				if( allFound ) {
					// return the cached resources asynchronously:
					var dO = $.Deferred();  
//					console.debug( 'readCache array - allFound', arr, itm );
					dO.resolve( itm );
					return dO
				}
			} else {
				// is a single item:
				idx = indexById( arr, itm.id );
				if( idx>-1 ) {
					// return the cached object asynchronously:
					var dO = $.Deferred();  
					dO.resolve( arr[idx] );
//					console.debug('readCache single item - found', ctg, 'from cache:',arr[idx]);
					return dO
				}
			}
//			console.debug('readCache - not found', ctg, itm);
		};
		return null
	}
/*	function cacheNode( e ) {  // ( hierarchy entry )
		// add or replace a node in a hierarchy;
		// e must specify the parent node and optionally a predecessor.
			function findNode( L, eId ) {
//				console.debug('findNode',L);
				let n=null;
				for( var h=L.length-1;h>-1;h-- ) {
					if( L[h].id==eId ) return L[h];
					n = findNode( L[h].nodes, eId );
					if( n ) return n
				};
				return null
			}
		if( !(e && e.parent) ) return null;
		// cycle through all hierarchies and nodes to find the parent:
	//	let pa = findNode( self.hierarchies, e.parent ); 
		// assuming that nodes are only inserted deleted in the selected hierarchy:
		let pa = findNode( self.selectedHierarchy.nodes, e.parent );
//		console.debug('cacheNode',e,pa);
		if( !pa ) return -1;
		if(pa.nodes==undefined) pa.nodes = [];
		return cacheAtPosition( pa.nodes, e )
	}
	function cacheAtPosition( L, e ) {  // ( list, entry )
		// add or update the element e in a list L:
		let n = indexById( L, e.id );
		let p = indexById( L, e.predecessor );
		if( n<0 ) 	{  
			// add, if not yet listed:
			L.splice(++p,0,e);   
//			console.debug('cacheA',p,L);
			return p
		};
		if( n!=p ) {
			// remove existing and add the new element:
			L.splice(n,1);  
			p = indexById( L, e.predecessor );			
			L.splice(++p,0,e);
//			console.debug('cacheA',p,L);
			return p
		};
		// update the existing otherwise:
		L[n] = e; 
		return n 
	}  */
});  

//////////////////////////
// global helper functions:
function dataTypeOf( pr, aTid ) {
	// given a property class ID, return it's dataType:
	return itemById( pr.dataTypes, itemById( pr.propertyClasses, aTid ).dataType )
	//                    get class
	//	   get dataType
}
function enumValStr( dT, prp ) {
	// for a property value of type ENUMERATION, create a comma-separated-value string of titles;
	// for all others, return the value as is:
	if( dT.type!='xs:enumeration' ) return prp.value;
	let ct = '',
		val,
		st = prp.title==CONFIG.stereotype,
		vL = prp.value.split(',');  // in case of ENUMERATION, value carries comma-separated value-IDs
	vL.forEach( function(vLi,i) {
		val = itemById(dT.values,vLi.trim());
		// If 'val' is an id, replace it by title, otherwise don't change:
		// For example, when an object is from a search hitlist or from a revision list, 
		// the value ids of an ENUMERATION have already been replaced by the corresponding titles.
		// Add 'double-angle quotation' in case of stereotype values.
		if( val ) ct += (i==0?'':', ')+(st?('&#x00ab;'+val.title+'&#x00bb;'):val.title)
		else ct += (i==0?'':', ')+vLi
	});
	return ct
}
function multipleChoice( pC, prj ) {
	prj = prj || myProject;
	// return 'true', if either the property type specifies it, or by default its datatype;
	// if defined, the property type's value supersedes the datatype's value:
//	return (pC.multiple || (pC.multiple==undefined && itemById(prj.dataTypes,pC.dataType).multiple))?true:false
	return pC.multiple || (typeof(pC.multiple)!='boolean' && itemById(prj.dataTypes,pC.dataType).multiple)
	// Note: specif-check applies the same logic in function 'checkpropValues(..)'
}
function titleIdx( aL ) {
	// Find the index of the property to be used as title.
	// The result depends on the current user - only the properties with read permission are taken into consideration
		
/*	// Note that the logic has been simplified.
	// Up until revision 0.92.34, the title property which was listed first in CONFIG.XXAttributes was chosen.
		var idx = -1;
		for( var c=0, C=CONFIG.headingAttributes.length; c<C; c++) {  // iterate configuration list; leading entry has priority
			idx = indexByName( aL, CONFIG.headingAttributes[c] );
			if( idx>-1 ) return idx
		};
	// Now, the first property which is found in the respective list is chosen.
	// ToDo: Check, if the results differ in practice ...
*/	
	for( var a=0,A=aL.length;a<A;a++ ) {
		// First, check the configured headings:
		if( CONFIG.headingAttributes.indexOf( aL[a].title )>-1 ) return a;
		// If nothing has been found, check the configured titles:
		if( CONFIG.titleAttributes.indexOf( aL[a].title )>-1 ) return a
	};
	return -1
}
function titleOf( item ) {
	// look for a translation, first:
	return i18n.lookup( item.title ) || item.id
}
function titleFromProperties( pL ) {
	// get the title from the properties:
	if( pL && pL.length>0 ) {
		// 1. look for a property serving as title:
		let ti = titleIdx( pL );
		if( ti>-1 ) {  // found!
			// Remove all formatting for the title, as the app's format shall prevail.
			// Before, remove all marked deletions (as prepared be diffmatchpatch).
			// ToDo: Check, whether this is at all called in a context where deletions and insertions are marked ..
			return pL[ti].value.replace(/<del[^<]+<\/del>/g,'').stripHTML().trim()
		};
		// 2. otherwise, find a description and take the beginning:
		// find a description and take the beginning:
		for( var a=0,A=pL.length;a<A;a++ ) {
			if( CONFIG.descriptionAttributes.indexOf( pL[a].title )>-1 ) 
				return pL[a].value.replace(/<del[^<]+<\/del>/g,'').stripHTML().truncate( CONFIG.maxTitleLength )
		}
	};
	return ''
}
function resTitleOf( res ) {
	// get the title from the properties or a replacement value in case of default:
	return res.title || titleFromProperties( res.properties ) || titleOf( res )
}
function elementTitleWithIcon( el ) {
	// add an icon to an element's title;
	// works for all types of elements, i.e. resources, statements and hierarchies.
	// The icon is defined in the elements's type:
	return CONFIG.addIconToInstance?resTitleOf(el).addIcon( itemById( myProject.allClasses, el['class'] ).icon ):resTitleOf(el)
}
/*	function classTitleWithIcon( t ) {
	// add the icon to a type's title, if defined:
	return (CONFIG.addIconToType?titleOf(t).addIcon( t.icon ):titleOf(t))
}*/
function hasContent( pV ) {
	return pV.stripHTML().trim().length>0
		|| /<object[^>]+(\/>|>[\s\S]*?<\/object>)/.test(pV)
		|| /<img[^>]+(\/>|>[\s\S]*?<\/img>)/.test(pV)
}
function initProp( pT ) {
	// create an empty property from the supplied class:
	var p = {
		title: pT.title,
		class: pT.id,
//		dataType: pT.dataType, 
		upd: pT.upd,
		del: pT.del
	};
	switch( itemById( myProject.dataTypes, pT.dataType ).type ) {
/*		case 'xhtml':
			p.value = '<div>\n</div>';
			break;
*/		case 'xs:enumeration':
			p.valueIDs = [];	// needed for editing
		default:
			p.value = ''
	};
	return p
}
function initPropR( pT ) {
	return pT.rea?initProp( pT ):null
}
function initPropC( pT ) {
	return pT.cre?initProp( pT ):null
}
function classifyProps( el ) {
	"use strict";
	// add missing (empty) properties and
	// classify properties into title, descriptions and other;
	// for resources, statements and hierarchies/specifications.
	// Note that here 'class' is the class object itself ... and not the id as is the case with SpecIF.
	var cP = {
		title: null,
		class: itemById( myProject.allClasses, el['class']),
		revision: el.revision,
		descriptions: []
	};
	// create a new list by copying the elements (do not copy the list ;-):
	cP.other = normalizeProps( myProject.propertyClasses, el.properties );

	// Now, all properties are listed in other;
	// in the following, the properties used as title or description will be identified
	// and removed from other.

	// a) Find and set the configured title:
	let a = titleIdx( cP.other );
	if( a>-1 ) {  // found!
		// Remove all formatting for the title, as the app's format shall prevail.
		// Before, remove all marked deletions (as prepared be diffmatchpatch).
		cP.title = deformat( cP.other[a].value );
		// remove title from other:
		cP.other.splice(a,1) 
//	} else {
		// In certain cases (ReqIF export or comment), there is no title property. 
		// Then some other value will be taken to set the title when posting the object/resource to the server, 
		// so that the hierarchy gets a title: see resTitleOf().
		// But here we want only 'real' titles and none, if there is none.
		// So we do NOT say, for example:
//		cP.title = titleOf( el )
	};
		
	// b) Check the configured descriptions:
	// We must iterate backwards, because we alter the list of other.
	for( a=cP.other.length-1;a>-1;a-- ) {
		if( CONFIG.descriptionAttributes.indexOf( cP.other[a].title )>-1 ) {
			// To keep the original order of the properties, the unshift() method is used.
//			cP.descriptions.unshift( cP.other.splice(a,1)[0] )
			cP.descriptions.unshift( cP.other[a] );
			cP.other.splice(a,1) 
		}
	};
//	console.debug( 'classifyProps', cP.title, cP.descriptions, cP.other );
	return cP

	function deformat( txt ) {
		// Remove all HTML-tags from 'txt',
		// but keep all marked deletions and insertions (as prepared be diffmatchpatch):
		// ToDo: consider to use this function only in the context of showing revisions and filter results,
		// 		 ... and to use a similar implementation which does not save the deletions and insertions, otherwise.
		let mL = [], dL = [], iL = [];
		txt = txt.replace(/<del[^<]+<\/del>/g, function($0) {
										dL.push($0);
										return 'hoKupokus'+(dL.length-1)+'#'
									});
		txt = txt.replace(/<ins[^<]+<\/ins>/g, function($0) {
										iL.push($0);
										return 'siMalabim'+(iL.length-1)+'#'
									});
		txt = txt.replace(/<mark[^<]+<\/mark>/g, function($0) {
										mL.push($0);
										return 'abRakad@bra'+(mL.length-1)+'#'
									});
		// Remove all formatting for the title, as the app's format shall prevail:
		txt = txt.stripHTML().trim();
		// Finally re-insert the deletions and insertions with their tags:
		// ToDo: Remove any HTML-tags within insertions and deletions
		if(mL.length) txt = txt.replace( /abRakad@bra([0-9]+)#/g, function( $0, $1 ) { return mL[$1] });
		if(iL.length) txt = txt.replace( /siMalabim([0-9]+)#/g, function( $0, $1 ) { return iL[$1] });
		if(dL.length) txt = txt.replace( /hoKupokus([0-9]+)#/g, function( $0, $1 ) { return dL[$1] });
		return txt
	}
}
function normalizeProps( cL, oL ) { // class list, original property list
	// Create a list of properties in the sequence of propertyClasses of the respective class.
	// Use those provided by the original list (oL) and fill in missing ones with default (no) values.

	let p,nL=[];  
	cL.forEach( function(c) {
		p = itemBy( oL, 'class', c.id )
			|| initPropR(c);
		if( p ) nL.push( p )
	});
	return nL // normalized property list
}

