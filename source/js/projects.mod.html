<script type="text/javascript">
/*	ReqIF Server: Project Selection
	Dependencies: jQuery 2.1+, knockout, bootstrap
	(C)copyright 2010-2018 enso managers gmbh (http://www.enso-managers.com)
	Author: se@enso-managers.com, Berlin
	We appreciate any correction, comment or contribution via e-mail to support@reqif.de            
*/

/* 	Concept for inter-app communication
		1. Every object can be addressed from externally with an URL.  
			- URL hash parameters are used to specify project, hierarchy, dialog and object (urlP)
			- The app starts right away with the specified dialog and view. 
			- The same mechanism is used to historize the user's navigation trail, so that the browser buttons can be used to step back and forth.
			- If the project is already cached, a minimum of server-calls is made. // ToDo: check the age of the cache and reload, if too old.
			
		Error cases:
		a.	The specified object cannot be found (has been deleted):
			- the first object in the selected hierarchy is shown on tab 'documents'
		b.	The specified hierarchy cannot be found (has been deleted):
			- the first object in the first hierarchy is shown on tab 'documents'
		c.	The specified project cannot be found (has been deleted):
			- the project table is shown
*/

var message = null,
	myProject = null,
	specif = null;

function ProjectsVM() {
	"use strict";
	var self = this;
	let options = null,
		movPermitted = false;
	self.list = [];  // list of projects
	self.mode = 'read';

	// title, global and item actions can be overridden when calling open().
	// global actions are offered as buttons at the top right corner:
	self.pageActions = [{ 	
		id: 'create',
		label: i18n.FnProjectCreate,
		fn: function() { self.createClicked() },
		classes: function() { return 'btn-success' }
	},{ 	
		id: 'import',
		label: i18n.FnProjectImport,
		fn: function() { window.open("./import.html", "_blank") },
		classes: function() { return 'btn-success' }
	},{ 	
		id: 'refresh',
		label: i18n.FnRefresh,
		fn: function() { userProfile.readMe().done( function() { self.show() } ) },   // readMe(): there may be new projects whose roles must be known ... 
		classes: function() { return 'btn-default'+(self.busy.value?' disabled':'') }
	}];

	self.selectedTab = ko.observable(null);  // selected Tab/HTML template
	self.selectTab = function( dlg ) {
		// skip, if no change:
		if( self.selectedTab()==dlg ) return false;	// no change
		// set new tab:
		self.selectedTab(dlg);
		return true		// changed
	};

	// Standard module interface methods:
	self.open = function( opt ) {
//		console.debug( 'projects.open',opt );
		if( !opt || !$.isFunction(opt.callback) ) return false;
		options = opt;  
		if( opt && opt.pageActions ) { 
			// keep only self.pageActions which are specified in opt.pageActions:
			for( var g=self.pageActions.length-1; g>-1; g-- ) {
				if( opt.pageActions.indexOf( self.pageActions[g].id )<0 ) { self.pageActions.splice(g,1) }
			}
		};

		message = new Message();
		message.open();
		myProject = new CachedProject();		// the cache layer
		myProject.open();
		specif = new Specif( myProject );
//		server.transform.set( myProject );
		server.open( myProject );	// ToDo: 'server.open' is called a second time, here. Works, but is sort of a hack.
		self.tree = new Tree( '#projTree' );
		self.views = new Views( [ 'projectAbout', 'projectAboutE' ] );
		self.hide()  
	};
	self.clear = function() {
		self.list = [];
		self.tree.init();
		self.clearHistory()
	};
	self.hide = function() {
		self.busy.reset();
		self.views.hide();
		self.selectTab(null) 
	};
	self.returnToCaller = function() {
		self.hide();
		self.clear();
		options.callback()
	};
	self.close = function() {
		console.debug( 'projects.close' );
		self.hide();
		specif = null;
		myProject.close();
		myProject = null;
		message.close();
		self.clear()
	};
	function handleError(xhr) {
		self.busy.set(false);
		switch(xhr.status) {
			case 983:		return;		// ignore the response, but continue.
			default:		stdError(xhr,self.returnToCaller)
		}
	}

	// entry to the module:
	self.show = function( urlP ) {
		console.debug( 'Entering projects: ', urlP );
		// Structure of 'urlP' depends on the calling app as defined in helper.XX.js.  Paramenters can be missing (user input ;-)
		
		// Depending on the app, the URL parameters are used to jump to a certain operation/dialog/object:
		if( urlP && urlP.pid && urlP.dlg ) {  
			switch( app.options.label ) {
				case i18n.LblSpecifications:
				case i18n.LblReader:
					// 'urlP' is {app: CONFIG.specifications, dlg: "abc", pid: "prj-id", sid: "spc-id", oids: ["obj-id", "obj-id",..]}
					// user wants to see content of the specified project:
					return self.update( urlP )  
				case i18n.LblProjectAdministration:
					// 'urlP' is {app: CONFIG.projects, dlg: "abc", pid: "prj-id"}
					// user wants to administer the specified project
					return self.administer( urlP )  
			}
		};

		// default: show the tree with projects.
		// get rid of the url parameters from the browser address line (if any), before calling the main view:
		self.busy.set( true );
		self.clear();
		self.selectTab( 'projects' );
		$( '#pageActions' ).html( self.pageActionBtns() );
		$( '#pageTitle' ).html( i18n.LblProjects );  
//		$( '#projectAboutNotice' ).empty();
		self.views.init();		// suppress a brief appearance before the tree and project list are shown.

//		console.debug( 'server.projects.read: ', myProject );
		server.projects().read()  	// get the project list
			.done(function(rsp) {
				console.debug( 'server.projects.read 2', rsp );
				for( var p=0,P=rsp.length;p<P;p++ )
					self.list.push({
						id: rsp[p].id,
						title: rsp[p].title,
						upd: rsp[p].upd
					});
				self.list.sort(function(a,b) { return a.title.toLowerCase() > b.title.toLowerCase() });

				buildTree();
				if( !self.tree.firstNode() ) {
					// tree is empty:
					self.refresh();
					return
				};
				// in both cases an event is triggered calling refresh:
				if( urlP && urlP.pid && urlP.pid.length>0 ) 
					self.tree.selectNodeByRef( {id: urlP.pid} )
				else
					self.tree.selectFirstNode()
			})
			.fail( handleError )
	}; 
	
	self.updateHistory = function() {
		if( !browser.supportsHtml5History ) return;

		var path = window.location.pathname.split('/'),  // get the path in pieces
			newState = path[path.length-1],   	// last element is 'appname.html' (without query or hash string)
			quO = projectsUrlParams();			// the current history status
//		console.debug( 'updateHistory', quO );

		// don't update, if unchanged or no project selected:
		if( quO.pid == self.tree.selectedNode.ref || !self.tree.selectedNode.ref ) {
			return
		};
/*		// reset history, if no project selected and history has a specified project:
		if( !self.tree.selectedNode.ref && quO.pid ) {   
			history.pushState(null,null,newState);    
			return
		};
*/
		// else:
		newState += '#'+CONFIG.keyPId+'/'+self.tree.selectedNode.ref;

		// update the browser history:
		history.pushState(null,null,newState);    
//		console.debug( 'updateHistory', newState );
	};
	self.clearHistory = function() {
		if( !browser.supportsHtml5History || !hasUrlParams() ) return;
		
		var path = window.location.pathname.split('/');  // get the path in pieces
		history.pushState(null,null,path[path.length-1])    // last element is 'appname.html' without url parameters;
	};
	
	function buildTree() {
		function loadTree( jqTr ) {
				function initTree( tr ) { 
				// similar to specifications-0.x.y.mod.html
					// initialize the tree
					$('#projTree').tree(
						{ data: tr,
						dragAndDrop: self.movPermitted }
					);

					// bind the handlers to tree events:
					$('#projTree').on(
						'tree.select',  // when a node is clicked or traversed by up/down keys
						function(event) {  // The clicked node is 'event.node'
	//						console.debug( 'selected node: ',event.node );
							// just update the node handle (don't use self.tree.selectNode() ... no need to update the tree element ;-):
							self.tree.selectedNode = event.node;
							self.refresh()
						}
					);
					return self.tree.firstNode()
				}
			if( !self.tree.get() )
				// on first entry, initialize:
				return initTree( jqTr )
			else
				// on subsequent entries, just load the tree:
				self.tree.saveState();
	//			console.debug( 'load', jqTr );
				self.tree.load( jqTr );
				self.tree.restoreState();
				return self.tree.selectedNode
		}
			function addF( cF, e ) {
				let n = indexBy( cF, 'name', e.name );
				if( n<0 ) 	{ cF.push( e ); return cF[cF.length-1].children }  // add folder, if it does not yet exist
				else		{ return cF[n].children } 
			}

//		console.debug( 'buildTree', self.list );
		let jqTreeData = []; 
							
		// 1. Create the tree entries for all projects:
		for( var p=0,P=self.list.length;p<P;p++ ) {
			let tL = self.list[p].title.split('/');	// last element is the project name; the ones before are nested folders

			for( var f=0,F=tL.length;f<F;f++ ) {
				if( f<tL.length-1 ) {
					jqTreeData = addF( jqTreeData, {name: tL[f], level: f, children:[]} )
				} else {
					// create the tree element for the project:
					jqTreeData.push({ 
						name: tL[tL.length-1].trim(),  
						ref:  self.list[p].id,
						level: f,
						category: CONFIG.project,
						children: []
					})
				}
			}
		};
//		console.debug('jqTreeData',jqTreeData);
		
		// 2. Load the tree: 
		return loadTree( jqTreeData )
	}
	
	self.busy = new State({
		showWhenSet: ['#spinner'],
//		hideWhenSet: ['#contentActions']			
		hideWhenSet: ['#pageActions','#contentActions']
//		hideWhenSet: ['#pageActions','#contentActions','.doneBtns']
	});

	// Multiple refresh requests in a short time are consolidated to a single refresh at the end.
	// This reduces the server traffic considerably, for example if the user quickly traverses the tree. 
	// Do finally refresh, if there has been no further request in a certain time period.
	self.refresh = function() {
//		console.debug( 'refresh +', refreshReqCnt );
		refreshReqCnt++;
		setTimeout(function() { tryRefresh() }, CONFIG.noMultipleRefreshWithin );
	};
	var refreshReqCnt = 0;
	function tryRefresh() {
		refreshReqCnt--;
		if( refreshReqCnt<1 ) doRefresh()
	}
	function doRefresh() {
		console.debug( 'doRefresh', self.mode, self.selected );
		switch( self.mode ) {
			case 'create':
				self.selected.set();  // create an empty project
				// no break
			case 'update':
				$( '#pageActions' ).html( self.pageActionBtns() );
				$( '#navBtns' ).empty();
				self.views.show( 'projectAboutE' ); 
				$( '#projectAboutNotice' ).html(self.mode=='create'?i18n.LblAddProject:i18n.LblUpdateProject);
				$( '#projectAboutForm' ).html( self.selected.editMeta() );
				self.selected.valid( i18n.LblProjectName );
				self.selected.focus( i18n.LblProjectName );
				self.selected.valid( i18n.LblDescription );
				self.selected.valid( i18n.LblTool );
				$( '#contentActions' ).html( self.selected.doneBtns() );
				$( '#doneBtns' ).html( self.selected.doneBtns() );
				break;
				
			case 'read':
				$( '#projectAboutNotice' ).empty();
				self.views.hide();

				switch( self.selectedTab() ) {
					case 'projects':
						// the project selection:
						if( self.tree.selectedNode ) {
							var lE = itemById( self.list, self.tree.selectedNode.ref );
							if( lE ) {
								// selected node is a project:
								self.views.hide();  // while it loads
								self.busy.set( true );
								myProject.read( lE )
									.done(function() {
										self.selected.set( myProject );
//										updateList( myProject.copy() );		// update and resort the list
										self.busy.reset();
										$( '#pageActions' ).html( self.pageActionBtns() );
										self.views.show( 'projectAbout', self.selected.details() ); 
										$( '#contentActions' ).html( self.selected.projectActionBtns() );
										$( '#navBtns' ).html( self.navBtns() )
									})
									.fail( handleError )
							} else {
								// selected node is a folder:
								self.busy.reset();
								$( '#pageActions' ).html( self.pageActionBtns() );
								self.views.show( 'projectAbout', '<div class="title1">'+self.tree.selectedNode.name+'</div>' ); 
								$( '#contentActions' ).html(self.folderActionBtns());
								$( '#navBtns' ).html( self.navBtns() )
							};
							self.updateHistory()
						} else {
							// no tree element selected:
							self.busy.reset();
							$( '#pageActions' ).html( self.pageActionBtns() );
							self.views.show( 'projectAbout', '<div class="notice-default">'+i18n.MsgNoProject+'</div>' ); 
							$( '#contentActions' ).empty();
							$( '#navBtns' ).html( self.navBtns() )
						};
						setContentHeight()
				}
		}
	}
		
/*	// Forward control to chosen sub-module:
	self.read = function( quO ) {
		// requires module 'specifications-X.XX.XX.mod.html'
		// 'quO' is {dlg: "abc", pid: "prj-id", sid: "spc-id", oids: ["obj-id", "obj-id",..]}
		console.info( "Loading project: '"+quO.pid+"' for content inspection" );
		message.show('');
		self.hide();
		var enableUpdate = false;
		return specs.show( quO, enableUpdate )
	};
*/	self.update = function( quO ) {
		// requires module 'specifications-X.XX.XX.mod.html'
		// 'quO' is {dlg: "abc", pid: "prj-id", sid: "spc-id", oids: ["obj-id", "obj-id",..]}
		console.info( "Loading project: '"+quO.pid+"' for content edition" );

		switch( app.options.label ) {
			case i18n.LblSpecifications:
			case i18n.LblReader:
				// we are in the specification app, so we can call the module directly:
				self.hide();
				return specs.show( quO );
			case i18n.LblProjectAdministration:
				// we are in the project admin app, so we switch apps:
				let sid = quO.sid?'/'+CONFIG.keySId+'/'+quO.sid:'',
					dlg = quO.dlg?'/'+quO.dlg:'/'+CONFIG.specDialogDefault;
//				console.debug( 'update', quO, quO.pid+sid+dlg );
				document.location.href = './specifications.html#'+CONFIG.keyPId+'/'+quO.pid+sid+dlg
		}
	};
	self.administer = function( quO ) {
		// requires module 'project-X.XX.XX.mod.html'
		console.info( "Loading project '"+quO.pid+"' for administration" );

//		if( !quo.dlg ) {
//			let quo.dlg = CONFIG.projectDialogDefault
//		};
		switch( app.options.label ) {
			case i18n.LblProjectAdministration:
				// we are in the project admin app, so we can call the module directly:
				self.clear();
				self.hide();
				return project.show( quO );
			case i18n.LblSpecifications:
			case i18n.LblReader:
				// we are in the specification app, so we switch apps:
//				document.location.href = 'projects.html#'+CONFIG.keyPId+'/'+self.tree.selectedNode.ref+'/'+CONFIG.projectDialogDefault
				document.location.href = './projects.html#'+CONFIG.keyPId+'/'+quO.pid+(quO.dlg?'/'+quO.dlg:'')
		}

	};

		function updateList( prj ) {
			// don't get the updated project from the server, because myProject.read cannot be called multiple times in direct succession
			// sort the project list, because the title may have changed:
			self.list.sort(function(laurel,hardy) { return laurel.title.toLowerCase() > hardy.title.toLowerCase() });
			buildTree();
			self.busy.set(false);
			self.tree.selectedNode = null;  // otherwise the next call has no effect, as old and new node are the same.
			// an event is triggered calling refresh:
			self.tree.selectNodeByRef( prj )
		}
	self.createProject = function( nP ) {
		self.mode = 'read';
		// a new project must have at least one content element:
		nP.spcTypes = [{
			id: 'HT-'+CONFIG.spcTypeOutline.toSpecifId(),
			longName: CONFIG.spcTypeOutline,
			description: 'Hierarchy type for outlines',
			attributes: [],
			category: 'hierarchyType',
			instantiation: ["auto","user"]
		}];
		nP.specs = [];
//		console.debug( 'createProject', nP );
		cacheE( self.list, nP );
		myProject.create( nP )
			.done( function() {updateList( nP )} )
			.fail( handleError )
	};
	self.updateProject = function( nP ) {
		self.mode = 'read';
		let lE = itemById( self.list, nP.id );
		for( var p in nP ) lE[p] = nP[p];						// update the provided properties
		myProject.updateMeta( nP )
			.done( function() {updateList( nP )} )
			.fail( handleError )
	};
	self.saveProject = function( nP ) {
		self.busy.set(true);
		switch( self.mode ) {
			case 'create': self.createProject( nP );	break;
			case 'update': self.updateProject( nP )
		}
	};
	self.createFolder = function() {
//		console.info( 'createFolder' )
		let dlg = new BootstrapDialog({
			title: i18n.LblAddFolder,
			type: 'type-success',
			message: function (thisDlg) {
				let form = $('<form id="attrInput" role="form" class="form-horizontal" ></form>');
				form.append( textInput( i18n.LblTitle, '', 'line' ) );
				return form },
			buttons: [
				{ 	label: i18n.BtnCancel,
					action: function(thisDlg){ thisDlg.close() }
				},
				{ 	label: i18n.phrase('BtnSaveItem',i18n.LblTitle),
					cssClass: 'btn-success', 
					action: function (thisDlg) {
							// Get folder title
							let p1 = getTextValue(i18n.LblTitle);

							// Cases of selected tree nodes:
							// - is a project: Add the new folder name directly in front of the project name: newFolder/projectName or otherFolders/newFolder/projectName
							// - is a folder on top level: add new name in front of the folder name of all projects found in the subtree
							// - is a folder on a lower level: insert new name in front of the selected folder name ... to all projects found in the subtree
							//
							// Thus:
							// - Insert the new name in front of the selected node name ... to all projects in the subtree.
							
								function insert( sN, fN, pN ) {	// selected node, foldername, projectName
									let pNL = pN.split( '/' );
									pN = '';
									for( var i=0, I=pNL.length; i<I; i++ ) {  
										pN += ((sN.level==i)?(fN+'/'):'') +pNL[i]
										pN += ((i<pNL.length-1)?'/':'')				// add '/' except for last element
									};
									return pN
								}
								function insertToAll( cN, fN ) {	// current node, folderName
									// insert folder name to a project name or apply this routine recursively to all children (either or !!)
									if( cN.ref ) {
//										console.debug( 'pr!', cN.name );
										let lE = itemById( projects.list, cN.ref );
										if( lE && lE.upd ) {
											var pr = {
												id: lE.id,
												title: insert( projects.tree.selectedNode, fN, lE.title ),
												description: lE.description,
												tool: lE.tool
											};
											projects.updateProject( pr )
										} else {
											message.show( i18n.Err403NoProjectFolder, 'danger', CONFIG.messageDisplayTimeNormal )
										};
										return
									};
									for( var i=0,I=cN.children.length;i<I;i++ ) {
//										console.debug( 'ch!', 1, cN.name, cN.children[i].name );
										insertToAll( cN.children[i], fN )
									}
								}

							insertToAll( projects.tree.selectedNode, p1 );
							thisDlg.close()
					}
				}]
		})
		.open()
	};
		
	self.remove = function( sN ) {  // selected node
		// remove the selected folder, subfolder or project:
		var dlg = new BootstrapDialog({
			title: i18n.MsgConfirm,
			type: 'type-danger',
			message: function() {
				if( projects.tree.selectedNode.ref ) return i18n.phrase( 'MsgConfirmProjectDeletion', sN.name );
				return i18n.phrase( 'MsgConfirmFolderDeletion', sN.name )
			},
			buttons: [
				{ label: i18n.BtnCancel,
				action: function(thisDlg){ thisDlg.close() }},
				{ label: i18n.BtnDelete,
				cssClass: 'btn-danger', 
				action: function (thisDlg) {
					if( projects.tree.selectedNode.ref ) {
						// the selected node is a project:
						console.info( "Deleting project '"+sN.name+"'." );
						self.busy.set( true );
						self.list.splice( indexById( self.list, self.tree.selectedNode.ref ), 1 );
						server.project( {id:self.tree.selectedNode.ref} ).remove()
							.done( function(prj,msg,xhr) { 
								self.busy.reset()
								buildTree();
								self.tree.selectFirstNode();
								doRefresh()
							})
							.fail( function(xhr) {
								self.busy.reset();
								switch( xhr.status ) {
									case 403:  // Forbidden, if the user is not a project admin
										message.show( xhr.statusText + " (" + xhr.status + "): "+i18n.Err403NoProjectDelete, 'danger', CONFIG.messageDisplayTimeNormal );
										return
								};
								handleError( xhr )
							})
					} else {
						// the selected node is a folder:
						console.info( "Deleting folder '"+sN.name+"'." );

							function remv( sN, pN ) {	// selected node, projectName
								var pNL = pN.split( '/' );
								pN = '';
								for( var i=0, I=pNL.length-1; i<I; i++ ) {  // for all except the last element = real project name
									pN += (sN.level==i)?'':pNL[i]+'/'
								};
								return pN + pNL[pNL.length-1]
							}
							function removeFromAll( cN ) {	// current node
								// remove folder name from a project or apply this routine recursively to all children (either or !!)
								if( cN.ref ) {
									// cN is a project:
									var lE = itemById( projects.list, cN.ref );
									if( lE && lE.upd ) {
										var pr = {
											id: lE.id,
											title: remv( projects.tree.selectedNode, lE.title ),
											description: lE.description,
											tool: lE.tool
										};
										projects.updateProject( pr )
									} else {
										message.show( i18n.Err403NoProjectFolder, 'danger', CONFIG.messageDisplayTimeNormal )
									};
									return
								};
								// cN is a folder:
								for( var i=cN.children.length-1;i>-1;i-- ) {
									removeFromAll( cN.children[i] )
								}
							}

						removeFromAll( projects.tree.selectedNode )
					};
					thisDlg.close()
				}}
			]
		})
		.open()
	};

	function ProjectAboutVM() {
		// View and edit all variables of the project about dialog.
		var self = this;
		self.value = {id:null};
		// display/edit fields for the properties:
		self.idV = null;
		self.titleE = '';
		self.descriptionE = '';
		self.toolE = '';
		self.spcCreTypes = [];

		self.set = function( c ) {
			if( !c || !c.id ) { 
//				if( !userProfile.iAmAdmin(project.selectedProject()) ) return null;  // should never get here.
				// create a new project:
				c = { 
					id: genID('P-'),
					title: '', 
					description: '', 
					tool: '',
					upd: true,
					exp: true		// if a user has the right to create a project, he may export it.
				}
			};
//			console.debug( 'selected.set', c );

			self.value = c;
			// preset the display/edit fields with the current values:
			self.idV = c.id;
			self.titleE = c.title;
			self.descriptionE = c.description;
			self.toolE = c.tool;
//			if(c.description) self.descriptionE = c.description;
//			if(c.tool) self.toolE = c.tool;
			// collect the hierarchy types for which the current user has a permission to create instances:
			self.spcCreTypes = [];
			var spc = null;
			for( var s=0,S=myProject.spcTypes.length;s<S;s++ ) {
				spc = myProject.spcTypes[s];
				if( spc.cre && (!spc.instantiation || spc.instantiation.indexOf('user')>-1) ) 
					self.spcCreTypes.push( spc ) 
			};
//			console.debug('set',c,self.titleE,self.descriptionE,self.toolE);
			return true
		};

		self.details = function() {
			if( projects.busy.value ) return '<div class="notice-default">'+i18n.MsgSearching+'</div>';
			if( !self.value ) return '<div class="notice-default">'+i18n.MsgNoProject+'</div>';
			
			var p = self.value;
			var rP = '';  // rendered project metadata

			// display only the main part of the title, i.e. omit the folder information:
			var pcs = p.title.split('/');
			rP = '<div class="title1" >'+pcs[pcs.length-1]+'</div>'
			
			// display the project description in full width, if available:
			if( p.description )
				rP +=	'<div style="max-height: 160px; overflow: auto;">'+attrV( undefined, p.description )+'</div>';

			// Present/activate button only if there is at least one hierarchy with create permission:
			// In case of RIF projects, the button will not be shown.
			if( self.spcCreTypes.length>0 )	
				rP += 	'<button onclick="projects.selected.createHierarchy()" class="btn btn-default btn-xs pull-right" style="margin-top:10px" >'+i18n.BtnAddSpec+'</button>';
					
			rP += 	'<div class="title2" >'+i18n.SpecIF_Outlines+'</div>';
			if( p.specs.length<1 )
				rP += '<div class="notice-danger" style="margin-left: 5%">'+i18n.MsgNoSpec+'</div>';

			for( var i=0,I=p.specs.length;i<I;i++ ) {
//				console.debug( 'outline', p, objTitleOf(p.specs[i]) );
				rP += 	'<div class="listEntry" style="margin-left: 5%">';
				if( p.specs[i].upd || p.specs[i].del ) {
					rP += 	'<div class="btn-group btn-group-xs pull-right" style="margin-top:3px" >';
					if( self.spcCreTypes.length>0 )
						rP +=	'<button onclick="projects.selected.createHierarchy(\''+p.specs[i].id+'\')" data-toggle="popover" title="'+i18n.LblCloneSpec+'" class="btn btn-default" >'+i18n.IcoClone+'</button>'
					else
						rP +=	'<button disabled class="btn btn-default" >'+i18n.IcoClone+'</button>';
					if( p.specs[i].upd )
						rP +=	'<button onclick="projects.selected.updateHierarchy(\''+p.specs[i].id+'\')" data-toggle="popover" title="'+i18n.LblUpdateSpec+'" class="btn btn-default" >'+i18n.IcoUpdate+'</button>'
					else
						rP +=	'<button disabled class="btn btn-default" >'+i18n.IcoUpdate+'</button>';
					if( p.specs[i].del )
						rP +=	'<button onclick="projects.selected.deleteHierarchy(\''+p.specs[i].id+'\')" class="btn btn-danger" >'+i18n.IcoDelete+'</button>'
					else
						rP +=	'<button disabled class="btn btn-default" >'+i18n.IcoDelete+'</button>';
					rP +=	'</div>'
				};

//				rP += 	'<div class="attributeTitle" ><a onclick="projects.showTab(CONFIG.specification)" >'+objTitleOf(p.specs[i])+'</a></div>';
//				if( app.options.label==i18n.LblSpecifications || app.options.label==i18n.LblReader )
					rP += 	'<div class="attributeTitle" ><a onclick="projects.update({pid:\''+p.id+'\',sid:\''+p.specs[i].id+'\'})" >'+objTitleOf(p.specs[i])+'</a></div>'  
//				else 
//					rP += 	'<div class="attributeTitle" >'+objTitleOf(p.specs[i])+'</div>';
//				document.location.href = 'specifications.html#'+CONFIG.keyPId+'/'+self.tree.selectedNode.ref+'/'+CONFIG.specDialogDefault

				// the description is sometimes used, but is rather irrelevant:
				if( p.specs[i].description ) 
					rP += 	'<div class="attribute attribute-content" >'+noCode(p.specs[i].description)+'</div>';
				
/*				// so far, the server does not supply these in projects.read():						
				for( var j=0,J=p.specs[i].attributes.length;j<J;j++ ) {
					rP +=	attrV( p.specs[i].attributes[j].title, p.specs[i].attributes[j].content )
				};
*/				rP +=	'</div>'
			};

			if( self.value.upd ) {    
				// title and action button for project administration (types and permissions):
				rP +=	'<button onclick="projects.administer({pid:\''+p.id+'\'})"' +
						' class="btn btn-xs btn-default pull-right" style="margin-top:10px"' +
						' data-toggle="popover" title="'+i18n.LblUpdateTypes+'" ' +
						'>'+i18n.IcoUpdate+'</button>' +
						'<div class="title2" >'+i18n.LblProjectAdministration+'</div>' +
				// action button for project properties (same as above at project level):
						'<button onclick="projects.updateClicked()"' +
						' class="btn btn-xs btn-default pull-right" style="margin-top:10px"' +
						' data-toggle="popover" title="'+i18n.LblUpdateProject+'"' +
						'>'+i18n.IcoUpdate+'</button>'
//			} else {
//				rP += 	'<button disabled class="btn btn-xs btn-default pull-right" >'+i18n.IcoUpdate+'</button>'
			};
			rP += 	'<div class="title2" >'+i18n.LblProjectDetails+'</div>' +
						attrV( i18n.LblMyRole, p.myRole ) +
						attrV( i18n.LblTool, p.tool ) +
						attrV( i18n.LblIdentifier, p.id );
			if( p.createdAt )
				rP += 	attrV( i18n.LblCreatedAt, localDateTime(p.createdAt) );

			return rP
		};
		self.allValid = false;
		self.valid = function(item) {
			// is  called on input to field named 'item'.
			// set color feedback on the input field:
			switch( item ) {
				case i18n.LblProjectName: 	setTextState( item, getTextValue(item).length>0?'has-success':'has-error' ); break;
				case i18n.LblDescription:
				case i18n.LblTool:			setTextState( item, 'has-success' ); 
			};
			// enable/disable the save button depending on the input state of all fields;
			// in this case only a non-zero length of the project name is required:
			let aV = getTextValue(i18n.LblProjectName).length>0;
			if( self.allValid != aV ) {
				self.allValid = aV;
				$( '#contentActions' ).html( self.doneBtns() );
				$( '#doneBtns' ).html( self.doneBtns() )
			}
		};
		self.focus = function(item) {
			setTextFocus( item )
		};
		self.createHierarchy = function( id ) {
			// Clone a hierarchy, when an id is specified; create a hierarchy, otherwise.
				function clone( nd ) {
					var nt = {
						id: genID('N-'),	
						ref: nd.ref,
						children: []
					};
					for( var i=0, I=nd.children.length; i<I; i++ ) {
						// get the first level children, then recursively their's:
						nt.children.push( clone( nd.children[i] ) )  
					};
					return nt
				}
				function addD( sp ) {
					let dlg = new BootstrapDialog({
						title: id?i18n.LblCloneSpec:i18n.LblAddSpec,
						type: 'type-success',
						message: function (thisDlg) {
							// ToDo: error message, if no specification type is found.
							let form = $('<form id="attrInput" role="form" class="form-horizontal" ></form>');
							form.append( textInput( i18n.LblTitle, sp.longName, 'line' ) );
							form.append( textInput( i18n.LblDescription, sp.description, 'line' ) );
							if( !sp.specType )
								form.append( radioInput( i18n.LblType, self.spcCreTypes ) );
							return form },
						buttons: [{
								label: i18n.BtnCancel,
								action: function(thisDlg){ 
									projects.busy.reset();
									thisDlg.close() 
								}
							},{ 	
								label: i18n.BtnSave,
								cssClass: 'btn-success', 
								action: function (thisDlg) {
									let spc = {
											id: genID('H-'),
											longName: getTextValue(i18n.LblTitle),
											description: getTextValue(i18n.LblDescription),
											specType: sp.specType || myProject.spcTypes[ radioValue( i18n.LblType ) ].id
									};
									if( sp.children && sp.children.length>0 )
										spc.children = clone( sp ).children;

									myProject.createContent( 'hierarchy', spc )
										.done( projects.refresh )
										.fail( handleError );
									thisDlg.close()
								}
							}]
					})
					.open()
				}
			// here, it starts:
			projects.busy.set( true );
			if( id )
				// Clone an existing hierarchy with its sub-tree;
				// at this point in time, the hierarchy root is known, but the hierarchy tree must still be loaded:
				myProject.readContent( 'hierarchy', {id: id}, true )	// true: force reload from server
					.done( addD )
					.fail( handleError )
			else
				// Create a new, empty hierarchy.
				// If there is just one hierarchyType, preselect it: 
				addD({ 
					longName: '', 
					description: '', 
					specType: self.spcCreTypes.length==1?self.spcCreTypes[0].id:null 
				})
		};
		self.updateHierarchy = function( id ) {
			projects.busy.set( true );
			let sp = itemById( self.value.specs, id );		// the concerned spec
			let dlg = new BootstrapDialog({
				title: i18n.LblUpdateSpec,
				type: 'type-default',
				message: function (thisDlg) {
					// ToDo: error message, if no specification type is found.
					let form = $('<form id="attrInput" role="form" class="form-horizontal" ></form>');
					form.append( textInput( i18n.LblTitle, sp.longName, 'line' ) );
					form.append( textInput( i18n.LblDescription, sp.description, 'line' ) );
					return form },
				buttons: [{
						label: i18n.BtnCancel,
						action: function(thisDlg){ 
							projects.busy.reset();
							thisDlg.close() 
						}
					},{
						label: i18n.BtnSave,
						cssClass: 'btn-primary', 
						action: function (thisDlg) {
							sp.longName = getTextValue(i18n.LblTitle);
							sp.description = getTextValue(i18n.LblDescription);
							myProject.updateContent( 'hierarchy', sp )
								.done( projects.refresh )
								.fail( handleError );
//							projects.refresh();
							thisDlg.close()
						}
					}]
			})
			.open()
		};
		self.deleteHierarchy = function( id ) {
			projects.busy.set( true );
			let sp = itemById( self.value.specs, id );		// the concerned spec
			let dlg = new BootstrapDialog({
				title: i18n.MsgConfirm,
				type: 'type-danger',
				message: i18n.phrase( 'MsgConfirmSpecDeletion', sp.longName ),
				buttons: [
					{ label: i18n.BtnCancel,
						action: function(thisDlg){ thisDlg.close() }
					},
					{ 	label: i18n.BtnDelete,
						cssClass: 'btn-danger', 
						action: function (thisDlg) {
							myProject.deleteContent( 'hierarchy', {id: sp.id } )
								.done( projects.refresh )
								.fail( handleError );
//							projects.refresh();
							thisDlg.close()
						}
					}
				]
			})
			.open()			
		};
		self.projectActionBtns = function() {
			var rB = '';  // rendered buttons

			// show the 'add folder' button for folders and projects with appropriate permission:
			if( self.value.upd ) {    
				rB = '<button class="btn btn-success" onclick="projects.createFolder()" >'+i18n.BtnAddFolder+'</button>'
			} else {
				rB = '<button disabled class="btn btn-default" >'+i18n.BtnAddFolder+'</button>'
			};

//			if( !self.selectedObject.valid() ) return rB;

/*			// Add the clone, update and delete buttons depending on the current user's permissions:
			if( self.clnPermitted() ) {
				rB += '<button class="btn btn-success" data-toggle="popover" onclick="project.cloneClicked()" title="'+i18n.LblClone+'" >'+i18n.IcoClone+'</button>';
			} else {
				rB += '<button disabled class="btn btn-default" >'+i18n.IcoClone+'</button>'
			};
			if( self.updPermitted() && self.tree.selectedNode && self.tree.selectedNode.ref ) {    
*/
//			console.debug( 'projectActionBtns', self.tree.selectedNode );
			// show the buttons depending on the project's permissions:
			if( self.value.upd ) {    
				rB += 	'<button class="btn btn-default" data-toggle="popover" onclick="projects.updateClicked()" title="'+i18n.LblUpdateProject+'" >'+i18n.IcoUpdate+'</button>'
			} else {
				rB += 	'<button disabled class="btn btn-default" >'+i18n.IcoUpdate+'</button>'
			};
			if( self.value.exp ) {    
				rB +=   '<button class="btn btn-default" data-toggle="popover" onclick="projects.export()" title="'+i18n.LblExport+'" >'+i18n.IcoExport+'</button>'
			} else {
				rB += 	'<button disabled class="btn btn-default" >'+i18n.IcoExport+'</button>'
			};
			// show the delete button for folders and projects with appropriate permission:
			if( self.value.del ) {    
				rB += '<button class="btn btn-danger" data-toggle="popover" onclick="projects.deleteClicked()" title="'+i18n.LblDeleteProject+'" >'+i18n.IcoDelete+'</button>'
			} else {
				rB += '<button disabled class="btn btn-default" >'+i18n.IcoDelete+'</button>'
			};
			return rB	// return rendered buttons for display
		};
		self.doneBtns = function() {
			let p = self.allValid?'onclick="projects.selected.saveMeta()"':'disabled';
			return '<button class="btn btn-default" onclick="projects.selected.cancel()" >'+i18n.BtnCancel+'</button>'
				+ '<button class="btn btn-primary" '+p+' >'+i18n.BtnSave+'</button>'
		};

		self.editMeta = function() {
			var rF = '<form class="form-horizontal" role="form">'
				+ textInput(i18n.LblIdentifier,self.idV,null,null)
				+ textInput(i18n.LblProjectName,self.titleE,'line','projects.selected.valid(\''+i18n.LblProjectName+'\')')
				+ textInput(i18n.LblDescription,self.descriptionE,'area','projects.selected.valid(\''+i18n.LblDescription+'\')')
				+ textInput(i18n.LblTool,self.toolE,'line','projects.selected.valid(\''+i18n.LblTool+'\')')
				+ '</form>';
//			console.debug('editMeta',rF);
			return rF
		};
		self.saveMeta = function() {
//			console.debug('saveMeta');
			// extract user-input directly from the form:
			projects.saveProject({
				id: self.value.id,
				title: getTextValue(i18n.LblProjectName),
				description: getTextValue(i18n.LblDescription),
				tool: getTextValue(i18n.LblTool)
			});
			// remove the form completely ( view() only hides it ), to avoid duplication of ids:
			$( '#projectAboutForm' ).empty()
		};
		self.cancel = function() {
			self.clear();
			projects.mode = 'read';  // ToDo: gehört nicht auf diese Ebene!
			projects.refresh()
		};
		self.clear = function() {
			// Reset all attributes which can be edited:
			self.titleE = '';
			self.descriptionE  = '';
			self.toolE = '';
			self.spcCreTypes = []
		};
		return self
	};
	self.selected = new ProjectAboutVM();

	self.navBtns = function() {
		if( self.mode!='read' || !self.tree.selectedNode ) return '';
		var rB = '<button class="btn btn-default" onclick="projects.previousClicked()" data-toggle="popover" title="'+i18n.LblPrevious+'" >'+i18n.IcoPrevious+'</button>' + // rendered buttons
				'<button class="btn btn-default" onclick="projects.nextClicked()" data-toggle="popover" title="'+i18n.LblNext+'" >'+i18n.IcoNext+'</button>';

		return rB	// return rendered buttons for display
	};
	self.folderActionBtns = function() {
		if( self.tree.selectedNode.ref ) return '';	// a project is selected   

			function upd( cN ) {
				// return true, if the user hase upd-permission for all projects in the sub-tree;
				// return false, if he has no upd-permission for at least one project:
				if( cN.ref ) {
					// cN is a project; a project is always a leaf:
					var lE = itemById( projects.list, cN.ref );
					return ( lE && lE.upd ) 
				};
				// else: cN is a folder:
				var res=null;
				for( var i=cN.children.length-1;i>-1;i-- ) {
					res = upd( cN.children[i] );
					if( !res ) return false
				};
				return true
			}
		
		var rB = '';  // rendered buttons
		// show the buttons in case of appropriate permissions:
		if( upd( self.tree.selectedNode ) ) {    
			rB = '<button class="btn btn-success" onclick="projects.createFolder()" >'+i18n.BtnAddFolder+'</button>'
				+ '<button disabled class="btn btn-default" >'+i18n.IcoUpdate+'</button>'
				+ '<button class="btn btn-danger" data-toggle="popover" onclick="projects.deleteClicked()" title="'+i18n.LblDeleteProject+'" >'+i18n.IcoDelete+'</button>'
		} else {
			rB = '<button disabled class="btn btn-default" >'+i18n.BtnAddFolder+'</button>'
				+ '<button disabled class="btn btn-default" >'+i18n.IcoUpdate+'</button>'
				+ '<button disabled class="btn btn-default" >'+i18n.IcoDelete+'</button>'
		};

		return rB	// return rendered buttons for display
	};
	self.pageActionBtns = function() {
		if( userProfile.userName == CONFIG.userNameAnonymous ) return '';
		var rB = '';
		for( var a=0,A=self.pageActions.length;a<A;a++ ) {
			rB += '<a class="btn '+self.pageActions[a].classes()+'" onclick="projects.pageActions['+a+'].fn()">'+self.pageActions[a].label+'</a>'
		};
		return rB
	};

	self.createClicked = function() {
		// create a new project:
		self.mode = 'create';
		self.refresh()
	};
	self.updateClicked = function() {
		// update the project metadata:
		self.mode = 'update';
		self.refresh()
	};
	self.deleteClicked = function() {
		// delete the selected project:
		self.remove( self.tree.selectedNode )
	};
	self.previousClicked = function() {
		self.tree.moveUp()
	};
	self.nextClicked = function() {
		self.tree.moveDown()
	};
	return self
};
var projects = new ProjectsVM();
ko.applyBindings( projects, $('#projects')[0] );

</script>

	<div id="spinner"/>
	<div id="pageNotice" class="notice-default"/>
	
<!-- ko if: selectedTab -->
<div id="projectsHeader" class="pageHeader">
	<div id="pageActions" class="btn-group btn-group-sm pageActions"></div>
	<div id="pageTitle" class="pageTitle" ></div>
</div>
<div id="projectsBody" >
	<div id="projSelection" class="selection" style="width:40%" >
		<div id="projTree" class="panel panel-default panel-tree" />
	</div>

	<div class="contentCtrl" style="width:60%" >
		<div id="navBtns" class="btn-group btn-group-sm"/>
		<div id="contentActions" class="btn-group btn-group-sm contentActions"/>
	</div>

	<div id="projectAbout" class="content" style="width:60%" ></div>
	
	<div id="projectAboutE" class="content" style="width:60%" >
		<div id="projectAboutNotice" class="title3 notice-primary" ></div>
		<div id="projectAboutForm" ></div>
		<div id="doneBtns" class="btn-group btn-group-sm doneBtns" ></div>
	</div>
</div>
<!-- /ko -->
