///////////////////////////////
/*	Cache Library for ReqIF Server.
	Dependencies: jQuery
	According to the concept of 'semantic versioning' (http://semver.org/),
		all minor versions j.n.p of this library work with all ReqIF Server minor versions j.n.q
	(C)copyright 2010-2017 enso managers gmbh (http://www.enso-managers.com)
	Author: se@enso-managers.com, Berlin
	We appreciate any correction, comment or contribution via e-mail to support@reqif.de            

	Naming:
	- readX: Get it from cache, if available, or otherwise from the server. Is always asynchronous.
	- loadX: Get it from the server and update the cache
	- cacheX: Add to cache
	- createX: Create a new instance of the specified data which is also cached.
	- updateX: Add non-existing instances and update existing instances. The cache is updated.
	
	Note:
	- No error handling - it is left to the calling layers
*/

function CachedProject() {  
	"use strict";
	// Construct a representative of the selected project with cached data:
	var self = this;
	// ToDo: enforce CONFIG.maxObjToCacheCount
	var autoLoadId = null,		// max 1 autoLoad chain
		autoLoadCb = null,		// callback function when the cache has been updated
		loading = false;		// true: data is being gathered from the server.
	self.exporting = false;		// prevent concurrent exports
//	self.cacheInstances = server && server.type=='ReqIF Server';  ... too much depends on self.objects, for now
	self.cacheInstances = true;
	
	// initialization is at the end of this constructor.
	self.open = function() {
		self.clear()
	};
	self.clear = function() {
		// initialize/clear all variables:
		self.id = '';
		self.title = '';
		self.description = '';
		self.tool = '';
		self.myRole = null;
		self.exportURL = null;
		self.cre = null;
		self.upd = null;
		self.del = null;
		self.exp = null;
		self.locked = null;		// the server has locked the project ( readOnly )

		self.dataTypes = [];
		self.specTypes = []; 	// common list of all specTypes including objTypes, relTypes ...
		self.objTypes = [];
		self.relTypes = [];
//		self.grpTypes = [];
		self.spcTypes = [];		// list of specification (hierarchy root) types
		self.objects = [];   	// list of objects as referenced by the hierarchies
		self.relations = [];
		self.specs = [];    	// listed specifications (aka hierarchies, outlines) of the project.   
		self.selectedSpec = null;  // selected spec, i.e the currently worked-on spec
		self.files = [];

		autoLoadId = null;  // stop any autoLoad chain
		autoLoadCb = null;
		loading = false;
		self.exporting = false;
		self.changedAt = null
	};
	self.set = function( iD ) { 
		// iD is data in 'internal' structure
		if( !iD ) return;
		
		self.clear();
		self.id = iD.id;
		self.title = iD.title;
		self.description = iD.description;
		self.tool = iD.tool;
		self.myRole = iD.myRole;
		self.exportURL = iD.exportURL;			// for ReqIF-Export
		cache( 'dataType', iD.dataTypes );		// universally used
		cache( 'specType', iD.specTypes );		// coming from ReqIF Server, types are mixed
		cache( 'objectType', iD.objTypes );		// universally used except ReqIF Server
		cache( 'relationType', iD.relTypes );	// universally used except ReqIF Server
		cache( 'hierarchyType', iD.spcTypes );	// universally used except ReqIF Server
		cache( 'object', iD.objects );			// universally used
		cache( 'relation', iD.relations );		// universally used
		cache( 'hierarchy', iD.specs );			// universally used
		if( iD.files && iD.files.length>0 ) self.files = iD.files;
		// top-level permissions for this project:
		self.cre = iD.cre && app.options.label!=i18n.LblReader;
		self.upd = iD.upd && app.options.label!=i18n.LblReader;
		self.del = iD.del && app.options.label!=i18n.LblReader;
		self.exp = userProfile.iAmAdmin({id:iD.id});
		self.locked = iD.locked;	
		if( iD.changedAt ) self.changedAt = iD.changedAt;
		if( iD.changedBy ) self.changedBy = iD.changedBy;
	//	console.debug('myProject.set',self)
	};
	self.close = function() {
		self.clear()
	};

	self.create = function( prj ) {
		// create a project, if there is no project with the given id, or replace a project with the same id.
		// (The roles/permissions and the role assignment to users are preserved, when import via ReqIF-file is made)
		// If there is no prj.id, it will be generated by the server.
		if( !prj ) return null;
		prj = specif.put( prj );    // transform to internal data structure
		console.debug('myProject.create',prj);

		self.abortFlag = false;

		// ToDo: schema and consistency check
		// Create the specified project:
		self.clear();
		self.id = prj.id;
		self.title = prj.title;
		self.description = prj.description;
		self.tool = prj.tool;
		self.myRole = i18n.LblRoleProjectAdmin;
		self.cre = self.upd = self.del = self.exp = true;

		var pend=0,
			sDO = $.Deferred();
		// 1. Create the project with all types:
		// (The roles/permissions and the role assignment to users are preserved, when import via ReqIF-file is made)
		sDO.notify(i18n.MsgLoadingTypes,30);
		cache( 'dataType', prj.dataTypes );
		cache( 'objectType', prj.objTypes );
		cache( 'relationType', prj.relTypes );
		cache( 'hierarchyType', prj.spcTypes );
/*		if( !server ) {
			sDO.resolve({status:0});
			return sDO
		};
*/
		// First, load dataTypes and classes:
		server.project( self ).create()
			.done( function() {
				console.info('project created',prj.title||prj.id);
				if( self.abortFlag ) {
					sDO.reject({status: 991, statusText:'Import aborted'});
					return   // stop the importing
				};
				// 2. Upload supplied files:
				sDO.notify(i18n.MsgLoadingFiles,40);
				// Create files for which there is an array buffer plus a name (id);
				// for example importSpecif adds the files themselves to prj.files,
				// but if a SpecIF file is imported without referenced files, then pass an empty array.
				// Thus, filter the file-list accordingly, before submitting it:
				self.files = forAll(prj.files, function(f) {return (f.buffer && f.id)? f : null } );
				self.createContent( 'file', prj.files || [] )
					.done( function() { 
						console.info(prj.files?prj.files.length:0, 'files created');
						if( self.abortFlag ) {
							sDO.reject({status: 991, statusText:'Import aborted'});
							return   // stop the importing
						};
						// 3. Create the resources (formerly objects):
						sDO.notify(i18n.MsgLoadingObjects,50);
		//				console.debug('loading objects',self.objects);
						self.createContent( 'object', prj.objects || [] )
							.done( function() { 
								console.info(prj.objects?prj.objects.length:0, 'objects created');
								if( self.abortFlag ) {
									sDO.reject({status: 991, statusText:'Import aborted'});
									return   // stop the importing
								};
								// Objects must exist, before relations and hierarchies can reference them:
								pend=2;
								// 4. Create the statements (formerly relations):
								sDO.notify(i18n.MsgLoadingRelations,70);
		//						console.debug('relation',self.relations);
								self.createContent( 'relation', prj.relations || [] )
									.done( function() { 
										console.info(prj.relations?prj.relations.length:0, 'relations created');
										sDO.notify(i18n.MsgLoadingHierarchies,80);
										if( self.abortFlag ) {
											sDO.reject({status: 991, statusText:'Import aborted'});
											return   // stop the importing
										};
										if( --pend<1 ) {
											sDO.notify(i18n.MsgProjectCreated,100);
											console.info('Project successfully created');
											sDO.resolve({status:0})
										}
									})
									.fail( sDO.reject );
								// 5. Create the hierarchies:
		//						console.debug('hierarchy',self.specs);
								self.createContent( 'hierarchy', prj.specs || [] )
									.done( function() { 
										console.info(prj.specs?prj.specs.length:0, 'hierarchies created')
										if( self.abortFlag ) {
											sDO.reject({status: 991, statusText:'Import aborted'});
											return   // stop the importing
										};
										if( --pend<1 ) {
											sDO.notify(i18n.MsgProjectCreated,100);
											console.info('Project successfully created');						
											sDO.resolve({status:0})
										}
									})
									.fail( sDO.reject )
							})
							.fail( sDO.reject )
					})
					.fail( sDO.reject )
			})
			.fail( sDO.reject );
		return sDO
	};
	self.read = function( prj, opts ) { 
		switch( typeof opts ) {
			case 'boolean':
				// for backward compatibility:
				opts = {reload: opts, loadAllSpecs: false, loadObjects: false, loadRelations: false};
				break;
			case 'object':
				// normal case (as designed):
//				if( typeof opts.reload!='boolean' ) opts.reload = false;
				break;
			default:
				opts = {reload: false}
		};

		console.debug( 'Entering cache.read', opts, self.id, prj );
		
		var pDO = $.Deferred();
		// Read from cache in certain cases:
		if( self.id && !opts.reload && ( !prj || prj.id==self.id ) ) {
			// return the loaded project:
			pDO.resolve( self );
			return pDO
		};
		// else, load from the server:
		if( prj && prj.id ) self.id = prj.id;			// prj is taken, if specified. Otherwise the same project is reloaded.
		if( self.id ) {									// at least the id must be specified
			return server.project({id: self.id}).read()	// do not call ..project(self)...
				.done( self.set );
/*			// should be OK, is not yet thoroughly tested:
			server.project({id: self.id}).read()		// do not call ..project(self)...
				.done( function(dta) {
					self.set( dta );
					self.load( opts )
						.done( function() {pDO.resolve( self )} )
						.fail( pDO.reject )
				})
				.fail( pDO.reject );
			return pDO
*/		};
		// else
		return null	
	};
	self.updateMeta = function( prj ) {
		if( !prj ) return null;
		for( var p in prj ) self[p] = prj[p];			// update only the provided properties
		// Update the meta-data (header):
		return server.project(self).update()
			// Do not take the result, as it is not (yet) returned by the server.
	};
	self.update = function( newD, mode ) {		
		// newD is new data in 'internal' data structure
		// add new elements
		// update elements with the same id
		// exception: since types cannot be updated, return with error in case newD contains incompatible types
		// There are tree modes with respect to the types:
		//	- "match": if a type in newD is already present and it differs, quit with error-code
		//	- "extend": new attributeTypes are added
		//	- "ignore": new attributeTypes and all depending attributes are ignored
		mode = mode || 'ignore';
//		console.debug('cache.update',newD,mode);
		newD = specif.put( newD );  // transform to internal data structure

		var rc = {},
			uDO = $.Deferred();

		// In first pass check, if there is any incompatible type making an update impossible:
		rc = typesAreCompatible('dataType',mode);
		if( rc.status>0 ) {
			uDO.reject( rc );
			return uDO
		};
		rc = typesAreCompatible('objectType',mode);
		if( rc.status>0 ) {
			uDO.reject( rc );
			return uDO
		};
		rc = typesAreCompatible('relationType',mode);
		if( rc.status>0 ) {
			uDO.reject( rc );
			return uDO
		};
		rc = typesAreCompatible('hierarchyType',mode);
		if( rc.status>0 ) {
			uDO.reject( rc );
			return uDO
		};
//		console.info("All existing types are compatible with '"+titleOf(newD)+"'");
		console.info("All existing types are compatible with '"+newD.title+"'");

		// In a second pass, start with creating any type which does not yet exist.
		// Start with the datatypes; the next steps will be chained by function updateNext:
		var pend=0;
		addNewTypes('dataType');

		return uDO
		
		function updateNext(ctg) {
			// chains the updating of types and instances in asynchronous operation:
			console.info('Finished updating:',ctg);
			// having finished with elements of category 'ctg', start next step:
			switch( ctg ) {
				case 'dataType': addNewTypes( 'objectType' ); break;
				case 'objectType': addNewTypes( 'relationType' ); break;
				case 'relationType': addNewTypes( 'hierarchyType' ); break;
				case 'hierarchyType': updateIfChanged( 'file' ); break;
				case 'file': updateIfChanged( 'object' ); break;
				case 'object': updateIfChanged( 'relation' ); break;
				case 'relation': updateIfChanged( 'hierarchy' ); break;
				case 'hierarchy': 
						uDO.notify(i18n.MsgProjectUpdated,100); 
						console.info('Project successfully updated');
						uDO.resolve(); 
						break;
				default: uDO.reject() //should never arrive here
			}
		}
		function typesAreCompatible( ctg, mode ) {
			let aL= null, nL= null; 
			switch( ctg ) {
				case 'dataType': aL = self.dataTypes; nL = newD.dataTypes; break;
				case 'objectType': aL = self.objTypes; nL = newD.objTypes; break;
				case 'relationType': aL = self.relTypes; nL = newD.relTypes; break;
				case 'hierarchyType': aL = self.spcTypes; nL = newD.spcTypes; break;
				default: return null //should never arrive here
			};
			// true, if every element in nL is compatibly present in aL or if it can be added;
			// loop backwards because only one variable is needed:
			let j=null, rC=null;
			for( var i=nL.length-1;i>-1;i-- ) {
				for( j=aL.length-1;j>-1;j-- ) {
//					console.debug('typesAreCompatible',aL[j],nL[i]);
					// if a single element is incompatible the lists are incompatible:
					rC = typeIsCompatible(aL[j],nL[i],mode);
					// on first error occurring, quit with return code:
					if( rC.status>0 ) return rC 
				}
			};
			return {status:0}
		}
		function typeIsCompatible(refT,newT,mode) {
			if(refT.id!=newT.id) return {status:0};
			if(refT.category!=newT.category) return {status:950, statusText:"new "+newT.category+" '"+titleOf(newT)+"' is incompatible"};
			// else: identifiers and categories are equal:
//			console.debug( 'typeIsCompatible', refT, newT );
			switch( newT.category ) {
				case 'dataType':
					// A dataType is incompatible, if an existing one has the same id and a smaller value range.
					// A dataType is compatible, if an existing one has the same id and an equal or larger value range.
					switch( refT.type ) {
						case 'BOOLEAN':	
						case 'DATETIME':	
							return {status:0};
						case 'XHTML':	
						case 'STRING':
//							console.debug( refT.maxLength>newT.maxLength-1 );
							if ( refT.maxLength==undefined )
								return {status:0};
							if ( newT.maxLength==undefined || refT.maxLength<newT.maxLength )
								return {status:951, statusText:"new dataType '"+titleOf(newT)+"' of type '"+newT.type+"' is incompatible"};
							return {status:0};
						case 'REAL':
							// to be compatible, the new 'accuracy' must be lower or equal:
							if( refT.accuracy<newT.accuracy )
								return {status:952, statusText:"new dataType '"+titleOf(newT)+"' of type '"+newT.type+"' is incompatible"};
							// else: go on ...
						case 'INTEGER':
							// to be compatible, the new 'max' must be lower or equal and the new 'min' must be higher or equal:
//							console.debug( refT.max<newT.max || refT.min>newT.min );
							if( refT.max<newT.max || refT.min>newT.min )
								return {status:953, statusText:"new dataType '"+titleOf(newT)+"' of type '"+newT.type+"' is incompatible"}
							else
								return {status:0};
						case 'ENUMERATION':
							// to be compatible, every value of the new 'enumeration' must be present in the present one:
							// ToDo: Add a new enum value to an existing enum dataType.
							var idx=null;
							for( var v=newT.values.length-1; v>-1; v-- ) {
								idx = indexById( refT.values, newT.values[v].id );
								// the id must be present:
								if( idx<0 ) 
									return {status:954, statusText:"new dataType '"+titleOf(newT)+"' of type '"+newT.type+"' is incompatible"};
								//  ... and the titles must be equal:
								if( refT.values[idx].title != newT.values[v].title )
									return {status:955, statusText:"new dataType '"+titleOf(newT)+"' of type '"+newT.type+"' is incompatible"}
							};
							return {status:0}
					};
					return null;	// should never arrive here ... as every branch in every case above has a return.
				case 'relationType':
					// To be compatible, all sourceTypes of newT must be contained in the sourceTypes of refT;
					// no sourceTypes means that all objectTypes are permissible as source.
					// ... and similarly for the targetTypes:
					if( refT.sourceTypes && !newT.sourceTypes
						|| refT.sourceTypes && newT.sourceTypes && !containsById( refT.sourceTypes, newT.sourceTypes ) ) {
								return {status:961, statusText:"new "+newT.category+" '"+titleOf(newT)+"' is incompatible"}
					};
					if( refT.targetTypes && !newT.targetTypes
						|| refT.targetTypes && newT.targetTypes && !containsById( refT.targetTypes, newT.targetTypes ) ) {
								return {status:962, statusText:"new "+newT.category+" '"+titleOf(newT)+"' is incompatible"}
					};
					// else: so far everything is OK, but go on checking ... (no break!)
				case 'objectType':
				case 'hierarchyType':
					// An objectType, relationType or hierarchyType is incompatible, if it has an equally-named attributeType with a different dataType
					// An objectType, relationType or hierarchyType is compatible, if all equally-named attributeTypes have the same dataType
					if( !newT.attributeTypes || !newT.attributeTypes.length ) 
								return {status:0};
					// else: The new type has at least one attribute.
					if( mode=='match' && (!refT.attributeTypes || !refT.attributeTypes.length) ) 
								return {status:963, statusText:"new "+newT.category+" '"+titleOf(newT)+"' is incompatible"};
					var idx=null;
					for( var a=newT.attributeTypes.length-1; a>-1; a-- ) {
						if( newT.attributeTypes[a].id ) {
							// If an id exists, it must be equal to one of refT's attributeTypes:
							idx = indexById( refT.attributeTypes, newT.attributeTypes[a].id )
						} else {
							// If there is no id, the type is new and there are no referencing instances, yet. 
							// So it does not matter.
							// But there must be an attributeType with the same name:
							idx = indexByName( refT.attributeTypes, newT.attributeTypes[a].longName )
						};
						if( idx<0 ) {
							// The attributeType in the new data is not found in the existing (reference) data:
							if( mode=='match' )
								// the attributeType is expected and thus an error is signalled:
								return {status:964, statusText:"new "+newT.category+" '"+titleOf(newT)+"' is incompatible"}
							else
								// cases 'extend' and 'ignore';
								// either the attribute will be created later on, or it will be ignored;
								// we are checking only in a first pass.
								continue;
						};
						//  else: the attributeType is present; in this case and in all modes the dataTypes must be equal:
						if( refT.attributeTypes[idx].dataType != newT.attributeTypes[a].dataType ) {
							return {status:965, statusText:"new "+newT.category+" '"+titleOf(newT)+"' is incompatible"}
						}
					};
					return {status:0}
			};
			return null		// should never arrive here ...
		}
		function addNewTypes( ctg ) {
			// Is commonly used for object, relation and hierarchy types with their attribute types.
			let rL= null, nL= null, rT=null, nT=null; 
			switch( ctg ) {
				case 'dataType': rL = self.dataTypes; nL = newD.dataTypes; break;
				case 'objectType': rL = self.objTypes; nL = newD.objTypes; break;
				case 'relationType': rL = self.relTypes; nL = newD.relTypes; break;
				case 'hierarchyType': rL = self.spcTypes; nL = newD.spcTypes; break;
				default: return null //should never arrive here
			};
			for( var i=nL.length-1;i>-1;i-- ) {
				nT = nL[i];
				rT = itemById(rL,nT.id);
				if( rT ) {
					// a type with the same id exists. 
					// ToDo: Add a new enum value to an existing enum dataType (server does not allow it yet)
					
					// Add a new attributeType to an existing type:
					switch( mode ) {
						case 'match': 
							// Reference and new data DO match (as checked, before) 
							// ... so nothing needs to be done, here.
							// no break
						case 'ignore':
							// later on, only attributes for which the user has update permission will be considered,
							// ... so nothing needs to be done here, either.
							break;
						case 'extend': 
							// add all missing attributeTypes:
							// ToDo: Is it possible that the user does not have read permission for an attributeType ?? 
							// Then, if it is tried to create the supposedly missing attributeType, an error occurs.
							// But currently all *types* are visible for everybody, so there is no problem.
							if( nT.attributeTypes && nT.attributeTypes.length>0 ) {
								// must create missing attributeTypes one by one in ascending sequence, 
								// because a newly added attributeType can be specified as predecessor: 
								addNewAT( rT, nT.attributeTypes, 0 )
							}
					}
				} else {
					// else: the type does not exist and will be created, therefore:
					pend++;
					console.info('Creating type',nT.longName);
					self.createContent(nT.category,nT)
						.done(function() {
							if( --pend<1 ) updateNext( ctg )
						})
						.fail( uDO.reject )
				}
			};
			// if no type needs to be created, continue with the next:
			if(pend<1) updateNext( ctg );
			return
				
				function addNewAT( r, nATs, idx ) {
					// r: existing (=reference) type with its attributeTypes
					// nATs: new list of attributeTypes
					// idx: current index of nATs
					if( nATs[idx].id?itemById( r.attributeTypes, nATs[idx].id ):itemByName( r.attributeTypes, nATs[idx].longName ) ) {
						// not missing, so try next:
						if( ++idx<nATs.length ) addNewAT( r, nATs, idx );
						return
					};

					// else: not found, so create:
					pend++;
					if( idx>0 ) 
						nATs[idx].predecessor = nATs[idx-1].id;

					// add the new attributeType also to r:
					let p = indexById( r.attributeTypes, nATs[idx].predecessor );
					console.info('Creating attributeType', nATs[idx].longName);
					// insert at the position similarly to the new type;
					// if p==-1, then it will be inserted at the first position:
					r.attributeTypes.splice( p+1, 0, nATs[idx] );
					nATs[idx].specType = r.id;  // eine Verzweiflungstat ... siehe server...js
					server.project({id:self.id}).specTypes({id:r.id}).attributeType(nATs[idx]).create()
						.done( function() {
							// Type creation must be completed before starting to update the instances:
							if( ++idx<nATs.length ) addNewAT( r, nATs, idx );
							if( --pend<1 ) updateNext( ctg )
						})
						.fail( uDO.reject )
				}
		}
		function updateIfChanged(ctg) {
			// Update a list of the specified category element by element, if changed.
			// Is commonly used for file, object, relation and hierarchy instances.
			// ToDo: Delete relations of all types provided by the import, which are missing 
			// ... not so easy to decide.
			// So perhaps restrict the deletion to those types with creation "auto" only.
			let itemL=null; 
			switch( ctg ) {
				case 'file': 
					uDO.notify(i18n.MsgLoadingFiles,40);
					// ToDo: check MD5 and upload any file only if changed.
					// For the time being, upload all files anyways. The server does not save duplicate blobs.
					// So we lose 'only' the transfer time.
					if( newD.files && newD.files.length>0 )
						self.updateContent(ctg,newD.files)
							.done( function() {
								// Wait for all files to be loaded, so that objects will have higher revision numbers:
								newD.files = [];
								updateNext(ctg)
							})
							.fail( uDO.reject )
					else
						updateNext(ctg);
					return;
				case 'object': itemL = newD.objects; uDO.notify(i18n.MsgLoadingObjects,50); break;
				case 'relation': itemL = newD.relations; uDO.notify(i18n.MsgLoadingRelations,70); break;
				case 'hierarchy': itemL = newD.specs; uDO.notify(i18n.MsgLoadingHierarchies,80); break;
				default: return null //should never arrive here
			};
			for( var i=0,I=itemL.length;i<I;i++ )
				updateInstanceIfChanged(ctg,itemL[i]);
			// if list is empty, continue directly with the next item type:
			if(pend<1) updateNext( ctg )
			return

			function contentChanged(ctg, r, n) { // ref and new objects
//				console.debug('contentChanged',ctg, r, n);
				// Is commonly used for object, relation and hierarchy instances.
				if( r.specType!=n.specType ) return null;  // fatal error, they must be equal!
				
				// As long as the hierarchy roots do not use attributes, the longName carries the title,
				// so check whether the specType of the new element is listed in the hierarchy types:
				if( ctg == 'hierarchy' ) return newD.spcTypes.indexOf( n.specType )<0 || r.longName!=n.longName;
				
				// Continue in case of objects and relations:
				let i=null, rA=null, nA=null, rV=null, nV=null;
				// 1) Are the attribute values equal?
				// Skipped, if the new instance does not have any attribute (list is empty or not present).
				// Relations and hierarchies often have no attributes.
				// Objects without attributes are useless, as they do not carry any user payload (information).
				// Note that the actual attribute list delivered by the server depends on the read privilege of the user.
				// Only the attributes, for which the current user has update privilege, will be compared.
				// Use case: Update diagrams with model elements only:
				//		Create a user with update privileges for objectType 'diagram' 
				//		and attributeType 'title' of objectType 'model-element'.
				//		Then, only the diagrams and the title of the model-elements will be updated.
				if( n.attributes && n.attributes.length>0 ) {
					for( i=(r.attributes?r.attributes.length:0)-1;i>-1;i--) {
						rA = r.attributes[i];
//						console.debug( 'update?', r, n);
						// no update, if the current user has no privilege:
						if( !rA.upd ) continue;	
						// look for the corresponding attribute:
						nA = itemBy( n.attributes, 'attributeType', rA.attributeType );
						// no update, if there is no corresponding attribute in the new data:
						if( !nA ) continue;	
						// in all other cases compare the content:
						let oT = itemById( myProject.objTypes, n.specType ),  // applies to both r and n
							rDT = dataTypeOf( myProject.dataTypes, oT, rA.attributeType ),
							nDT = dataTypeOf( newD.dataTypes, oT, nA.attributeType );
						if( rDT.type!=nDT.type ) return null;  // fatal error, they must be equal!
						switch( nDT.type ) {
							case 'ENUMERATION':
								// content has a comma-separated list of value-IDs,
								rV = enumValStr(rDT,rA);
								nV = enumValStr(nDT,nA);
//								console.debug('contentChanged','ENUM',rA,nA,rV!=nV);
								if( rV!=nV ) return true;
								break;
							case 'XHTML': 
						//		rV = toHex(rA.content.stripCtrl().reduceWhiteSpace());
						//		nV = toHex(fileRef.toServer(nA.content).stripCtrl().reduceWhiteSpace());
						//		rV = rA.content.stripCtrl().reduceWhiteSpace();
								rV = rA.content;
								// apply the same transformation to nV which has been applied to rV before storing:
						//		nV = fileRef.toServer(nA.content).stripCtrl().reduceWhiteSpace();
								nV = fileRef.toServer(nA.content);
						//		console.debug('contentChanged','XHTML',rA,nA,rV!=nV);
								if( rV!=nV ) return true;
								// If a file is referenced, pretend that the object has changed.
								// Note that a resource always references a file having the next lower revision number than istself.
								// It is possible that a file has been updated, so a referencing resource must be updated, as well.
								// ToDo: Analyse whether a referenced file has really been updated.
								if( RE.tagNestedObjects.test(nV)
									||  RE.tagSingleObject.test(nV) ) return true;
								break;
							default: 
								if( rA.content!=nA.content ) return true
						}
					}
				};
				// 2) Statements must have equal sources and targets - with equal revisions?
				if( ctg == 'relation' ) {
	//				if( n.source.id!=r.source.id || n.source.revision!=r.source.revision) return true;
	//				if( n.target.id!=r.target.id || n.target.revision!=r.target.revision) return true;
					if( n.source.id!=r.source.id 
						|| n.target.id!=r.target.id ) return true
				};
				return false // ref and new are the same
			}
			function updateInstanceIfChanged(ctg,nI) {
				// Update an element/item of the specified category, if changed.
				pend++;
				self.readContent(ctg,nI,true)	// reload from the server to obtain most recent data
					.done( function(rI) {
						// compare actual and new item:
//						console.debug('updateInstanceIfChanged',ctg,rI,nI);
						// ToDo: Detect parallel changes and merge interactively ...
						if( Date.parse(rI.changedAt)<Date.parse(nI.changedAt) 
								&& contentChanged(ctg,rI,nI) ) {
							nI.revision = rI.revision; // avoid the optimistic locking 
							// attributes without update permission will not be sent to the server:
							nI.upd = rI.upd;
							nI.del = rI.del;
							let rA=null, nA=null;
							for( var a=rI.attributes.length-1;a>-1;a-- ) {
								// in case the nI.attributes are supplied in a different order:
								rA = rI.attributes[a];
								nA = itemBy(nI.attributes,'attributeType',rA.attributeType);
								if( nA ) {
									nA.upd = rA.upd;
									nA.del = rA.del
								}
							};
							console.info('Updating instance',nI.longName);
							// ToDo: Test whether only supplied attributes are updated by the server; otherwise implement the behavior, here.
							self.updateContent( ctg, nI )
								.done( updateTreeIfChanged( ctg, rI, nI ) )	// update the tree, if necessary.
								.fail( uDO.reject )
						} else {
							// no change, so continue directly:
							updateTreeIfChanged( ctg, rI, nI )	// update the tree, if necessary.
						}
					})
					.fail( function(xhr) {
						switch( xhr.status ) {
							case 403:
								// This is a hack to circumvent a server limitation.
								// In case the user is not admin, the server delivers 403, if an object does not exist,
								// whereas it delivers 404, if it is an admin.
								// Thus: If 403 is delivered and the user has read access according to the objectType,
								// do as if 404 had been delivered.
								var aT = itemById(myProject.specTypes,nI.specType);
//								console.debug('403 instead of 404',nI,aT);
								if( !aT.rea || !aT.cre ) { uDO.reject(xhr); return };
								// else the server should have delivered 404, so go on ...
							case 404:
//								console.debug('not found',xhr.status);
								// no item with this id, so create a new one:
								self.createContent(ctg,nI)
									.done(function() {
										if( --pend<1 ) updateNext( ctg )
									})
									.fail( uDO.reject )
								break;
							default: 
								uDO.reject(xhr)
						}
					})
			}
			function updateTreeIfChanged( ctg, aI, nI ) {
				// Update all children (nodes) of a hierarchy root.
				// This is a brute force solution, since any mismatch causes an update of the whole tree.
				// ToDo: Add or delete a single child as required.
				// ToDo: Update the smallest possible subtree in case addition or deletion of a single child is not sufficient.

					function newIds(h) {
						// new and updated hierarchy entries must have a new id (server does not support revisions for hierarchies):
						for ( let i=h.children.length-1; i>-1; i-- ) {
							h.children[i].id = genID('HN-');
							newIds(h.children[i])
						}
					}
					function treeChanged(a,n) {
						// Equal hierarchies?
						// All children (nodes in SpecIF terms) on all levels must have the same sequence.
						return nodesChanged(a.children,n.children)

						function nodesChanged(aL,nL) {
//							console.debug( 'nodesChanged',aL,nL )
							if( (!aL || aL.length<1) && (!nL || nL.length<1) ) return false;	// no update needed
							if( aL.length!=nL.length ) return true;								// update!
							for ( let i=nL.length-1; i>-1; i-- ) {
								// compare the references only, as the hierarchy ids can change:
								if( !aL[i] || aL[i].ref!=nL[i].ref ) return true;
								if( nodesChanged(aL[i].children,nL[i].children) ) return true
							}; 
							return false
						}
					}
					
				// Note: 'updateTreeIfChanged' is called for instance of ALL types, even though only a hierarchy has children.
				// In case of an object or relation, the tree operations are skipped:
				if( ctg == 'hierarchy' && treeChanged(aI,nI) ) {
					message.show( i18n.MsgOutlineAdded, 'info', CONFIG.messageDisplayTimeShort );
//					self.deleteContent('hierarchy',aI.children);		// can be be prohibited by removing the permission, but it is easily forgotten to change the role ...
					newIds(nI);
					server.project(myProject).specification(nI).createChildren()
						.done( function() {
							if( --pend<1 ) updateNext( ctg )
						})
						.fail( uDO.reject )
				} else {
					// no hierarchy (tree) has been changed, so no update:
					if( --pend<1 ) updateNext( ctg )
				}
			}
		}
	};

	self.createContent = function( ctg, item ) {  
		// item can be a js-object or a list of js-objects
		// ctg is a member of [dataType, objectType, relationType, hierarchyType, attributeType, object, relation, hierarchy]
		// ...  not all of them may be implemented, so far.
		// cache the content before sending it to the server, as the result is not received after sending (except for 'object' and 'relation')

		switch( ctg ) {
//			case 'file': 			
//				break;
			case 'node':
				return null;  // not supported
//			case 'attributeType':
//				cache( ctg, item ); 
//				break;
			case 'object':
			case 'relation':
			case 'hierarchy':
				// add the baseType to property values to simplify the transformation for storing:
				addBaseTypes( item );
				// no break
			default:
				// if current user can create an item, he has the other permissions, as well:
				addPermissions( item );
				item.createdAt = new Date().toISOString();
				item.createdBy = item.changedBy;
				cache( ctg, item )
		};
//		console.debug('createContent',ctg,item);
		return server.project({id: self.id}).createContent( ctg, item )
			// rsp is 'null' in all cases except 'object' and 'relation'
			// even if returned, the item's permissions are not set.
//			.done(function(rsp) { 
//					if(rsp) cache( ctg, addPermissions(rsp) ) 
//					else	rsp = itemById( cacheOf(ctg), item.id )
//			})	
	};
	self.readContent = function( ctg, item, opts ) {  
		// ctg is a member of [dataType, objectType, relationType, hierarchyType, object, relation, hierarchy]
		//  for compatibility with older callers:
		if( typeof opts == 'boolean' )
			opts = {reload: opts};
		// .. and by default:
		if( !opts )
			opts = {reload: false};
		
		if( !opts.reload ) {
//			switch( ctg ) {
//				case 'file': 
//					break;
//				default:
					// Try to read from cache:
					var dO = readCache( ctg, item, false );
					if( dO ) return dO;
//			}
		};

		// Empty the cache, when all items are reloaded to make sure there are no zombies, 
		// e.g. when other users have deleted an element.
		if( item=='all' ) {
			let c = cacheOf( ctg );
			c.length = 0   // empty the list, but do not change the data address, as it is shared by others.
		};
		
		switch( ctg ) {
			case 'node':	// can only be read as part of its hierarchy; is useless on its own.
				return null;  // not supported
			case 'object':
				if( !Array.isArray(item) && !item.id ) 
					// it is assumed that item specifies a query condition and all corresponding objects are returned:
					return queryObjects( item, opts.reload );
				// if item is a list, assume it is a list of ids: the specified objects will be returned,
				// if item specifies a single id, the object is returned:
			default:
				return server.project({id: self.id}).readContent( ctg, item )
					.done(function(rsp) { cache( ctg, rsp ) })
		}
	};
	self.updateContent = function( ctg, item ) {  
		// ctg is a member of [object, relation, hierarchy], 'null' is returned in all other cases.
		// (server does not allow type updates, so far.)

		switch( ctg ) {
			case 'node':	// nodes can only be created or deleted
				return null;  // not supported
//			case 'file': 
//				break;
			case 'object':
			case 'relation':
			case 'hierarchy':
				// add the baseType to property values to simplify the transformation for storing:
				addBaseTypes( item );
				// no break
			default:
//				console.debug('updateContent - cache', ctg );
				item.changedAt = new Date().toISOString();
				item.changedBy = userProfile.userName;
				cache( ctg, item )
		};
		console.debug('updateContent',self.id,ctg,item );
		// implemented only for single elements, not lists, so far:
		return server.project({id: self.id}).updateContent( ctg, item )
			// ReqIF Server: rsp is 'null' in all cases except 'object' and 'relation'
			// even if returned, the item's permissions are not set.
//			.done(function(rsp) { 
//					if(rsp) cache( ctg, addPermissions(rsp) ) 
//					else	rsp = itemById( cacheOf(ctg), item.id )
//			})	
	};
	self.deleteContent = function( ctg, item ) {  
		// ctg is a member of [dataType, objectType, relationType, hierarchyType, attributeType, object, relation, hierarchy]
			function isInUse( ctg, itm ) {
					function dTIsInUse( L, dT ) {
						let i=null;
						for( var e=L.length-1;e>-1;e-- ) {
							i = L[e].attributeTypes?indexBy(L[e].attributeTypes,'dataType',dT.id):-1;
//							console.debug('dTIsInUse',dT,L,e,i); 
							if( i>-1 ) return true
						};
						return false
					}
					function sTIsInUse( ctg, sT ) {
						let c = ctg.substr(0,ctg.length-4),
							L = cacheOf(c),	// xyzType --> xyz
							i = indexBy(L,ctg,sT.id);
//						console.debug('sTIsInUse',sT,c,L,i); 
						// Problem: In project.html, the object cache is empty, but the objectType may be in use, anyways.
						// Similarly with relations and hierarchies.
						// In these cases the server will refuse to delete the type.
						return ( i>-1 )
					}
					function aTIsInUse( L, aT ) {
						if( L==undefined ) return false; // can't be in use, if the list is not (yet) defined/present.
						let i=null;
						// Problem: In project.html, the object cache is empty, but the attributeType may be in use, anyways.
						// Also a deleted object may have used the attributeType.
						// As it stores only the newest types, the ReqIF Server will refuse to delete the type.
						// In case of PouchDB, all revisions of classes/types are stored, so it is sufficient to check whether there are currently some elements using the type.
						// Similarly with relations and hierarchies.
						for( var e=L.length-1;e>-1;e-- ) {
							i = L[e].attributes?indexBy(L[e].attributes,'attributeType',aT.id):-1;
//							console.debug('aTIsInUse attributeType',aT,L,e,i); 
							if( i>-1 ) return true
						};
						return false
					}
//				console.debug('isInUse',ctg,item);
				switch( ctg ) {
					case 'dataType':		return dTIsInUse(self.specTypes,itm);
					case 'objectType':
					case 'relationType':
					case 'hierarchyType':	return sTIsInUse(ctg,itm);
					case 'attributeType':	return aTIsInUse(self.objects,itm)
												|| aTIsInUse(self.hierarchies,itm)
												|| aTIsInUse(self.relations,itm) 
				};
				return false
			}
		
//		console.debug('deleteContent',ctg,item);
		var dDO = $.Deferred();
		// Do not try to delete types which are in use;
		// the ReqIF Server checks it, but the caching mechanism doesn't:
		switch( ctg ) {
			case 'node':
				return null;  // not supported
			case 'attributeType':	
			case 'dataType':
			case 'objectType':
			case 'relationType':
			case 'hierarchyType':	if( Array.isArray(item) ) return null;	// not yet supported
									if( isInUse(ctg,item) ) {
										dDO.reject({status:972, statusText:i18n.Err400TypeIsInUse});
										return dDO
									};
									// no break;
			default: 				uncache( ctg, item );
		};

//		console.debug('deleteContent',ctg,item );
		server.project({id: self.id}).deleteContent( ctg, item )
			.done( dDO.resolve )
			.fail( dDO.reject );
		return dDO;
	};
	self.createNode = function( el ) {
		// creating a node is updating the hierarchy:
		var cPr = $.Deferred();
		let sId = self.selectedSpec.id, // memorize
			nI; 
		// 1. reload hierarchy to minimize update conflict,
		//    just specify the id to obtain the last revision:
		self.readContent( 'hierarchy', {id:self.selectedSpec.id}, {reload: true} )
			.done( function( nH ) {
				console.debug('createNode current hierarchy',nH,el);
				cache( 'hierarchy', nH );
				self.selectedSpec = itemById( self.specs, sId ) // update address
				console.debug('createNode selected hierarchy',sId,self.selectedSpec);
				// 2. insert the node:
				nI = cache( 'node', el );
				console.debug('createNode updated hierarchy',nI,self.selectedSpec);
				if( typeof nI == 'number' && nI>-1 ) 
					// 3. update the hierarchy:
					self.updateContent( 'hierarchy', self.selectedSpec )
						.done( cPr.resolve )
						.fail( cPr.reject )
			})
			.fail( cPr.reject )
		return cPr
	};
	self.moveNode = function( el ) {
	};
	self.deleteNode = function( el ) {
		// deleting a node is updating a hierarchy:
		var dPr = $.Deferred();
		let sId = self.selectedSpec.id; // memorize
		let nI
		// 1. reload hierarchy to minimize update conflict,
		//    just specify the id to obtain the last revision:
		self.readContent( 'hierarchy', {id:self.selectedSpec.id}, {reload: true} )
			.done( function( nH ) {
				console.debug('deleteNode current hierarchy',nH,el);
				cache( 'hierarchy', nH );
				myProject.selectedSpec = itemById( self.specs, sId ) // update address
				console.debug('deleteNode selected hierarchy',sId,self.selectedSpec);
				// 2. delete the node:
				nI = uncache( 'node', el );
				console.debug('deleteNode updated hierarchy',nI,self.selectedSpec);
				if( nI ) 
					// 3. update the hierarchy:
					self.updateContent( 'hierarchy', self.selectedSpec )
						.done( dPr.resolve )
						.fail( dPr.reject )
			})
			.fail( dPr.reject )
		return dPr
	};

	self.initObject = function( oT ) { 
		// Create an empty form (object instance) for the specType oT:
		var fDO = $.Deferred();
//		console.debug( 'initObject', oT );

		// Get the specType's permissions. So far, it's attribute permissions are not loaded ...
		self.readContent( 'objectType', oT, true )		// reload the type from the server
			.done( function(dta) {
				// return an empty object instance of the given type: 
				var obj = 
					{ specType: dta.id,
					longName: '',
//					title: '',
					upd: true,
					attributes: [] };
				for( var a=0, A=dta.attributeTypes.length; a<A; a++ ) {
					if( dta.attributeTypes[a].cre ) {
						obj.attributes.push( initAttrC(dta.attributeTypes[a]) )
					}
				};
//				console.debug('fillObject',obj);
				if( obj.attributes.length ) 
					fDO.resolve( obj )
				else
					fDO.reject({status:977, statusText:i18n.ErrInconsistentPermissions})
			})
			.fail( fDO.reject );
		return fDO
	};
	self.readRelationsOf = function( obj, showComments ) {  
		// Get the relations of an object ... there are 2 use-cases:
		// - All relations between objects appearing in a hierarchy shall be shown for navigation;
		//   it is possible that an object is deleted (from all hierarchies), but not it's relations.
		//   --> set 'showComments' to false
		// - All comments referring to the selected object shall be shown;
		//   the object is found in the cache, but the comment is not.
		//   --> set 'showComments' to true
//		return server.project({id: self.id}).object( obj ).relations().read()
		return server.project({id: self.id}).readContent('relation',{resource: obj})
			.done(function(rsp) {
//				console.debug('readRelationsOf',rsp);
					function notReferenced( oId ) {
						for( var s=self.specs.length-1; s>-1; s-- )
							if( self.specs[s].objectRefs.indexOf( oId )>-1 ) return false;
						return true
					}
				for( var i=rsp.length-1;i>-1;i-- ) {
//					console.debug('readRelationsOf',rsp[i]);
					if( 	// In case of a related comment, the comment itself is not cached, but the target:
							showComments && (
									indexById(self.objects,rsp[i].target.id)<0
								||	rsp[i].longName!=CONFIG.relTypeCommentRefersTo
							)
							// otherwise, related source and target must be referenced in the tree to be navigable:
							// also, the relation must not be declared 'hidden':
							||	!showComments && (
									notReferenced( rsp[i].source.id )
								||	notReferenced( rsp[i].target.id )
								|| 	CONFIG.hiddenRelations.indexOf( rsp[i].longName )>-1
							)
						) {
//								console.debug('readRelationsOf - discard',rsp[i]);
								rsp.splice(i,1)
					}
				};
				// cache the remaining ones (having both source and target and not being hidden):
				cacheL( self.relations, rsp )
			})
	};
	self.startAutoLoad = function( cb ) {
//		if( !self.cacheInstances ) return;
//		console.info( 'startAutoLoad' );
		if( typeof cb === "function" ) { autoLoadCb = cb };
		autoLoadId = genID( 'aU-' );
		// get all objects from the server to fill the cache:
		setTimeout( function() { autoLoad(autoLoadId) }, 600 )  // start a little later ...			
	};
	self.stopAutoLoad = function() {
//		console.info('stopAutoLoad');
		autoLoadId = null;
		loading = false
	};
	self.loadInstances = function( cb ) {
		// for the time being - until the synchronizing will be implemented:
//		if( !self.cacheInstances ) return;
		// load the instances of the selected hierarchy (spec) into the cache (but not the types):
//		console.debug( 'self.loadInstances', self.selectedSpec, cb );
		if( self.selectedSpec ) {
			loading = true;  
			// update all objects referenced by the selectedSpec:
			loadObjsOf( self.selectedSpec )
				.done( function() {			
//					loadRelsOf( self.selectedSpec );
					// update the hierarchy (outline).
					// it is done after the objects to reflect any change in the hierarchy made during the loading.
					self.readContent( 'hierarchy', self.selectedSpec, true )	// true: reload
						// - call cb to refresh the app:
						.done( function() { 
							if( typeof cb=="function" ) cb();
							loading = false
						})
						.fail( function(xhr) { 
							loading = false
						})
				})
				.fail( function(xhr) { 
					loading = false
				})
		}
	};
/*	self.load = function(opts) {
		var lDO = $.Deferred();

		// load referenced objects and relations ... 
		if( opts.loadObjects ) {
			if( opts.loadAllSpecs ) 
				loadAll( 'object' )
					.done( function() { 
						if( opts.loadRelations )
							return loadAll( 'relation' )
								.done( lDO.resolve )
								.fail( lDO.reject );
						// else
						lDO.resolve()
					})
					.fail( lDo.reject )
			else					
				loadObjsOf( self.selectedSpec )
					.done( function() { 
						if( opts.loadRelations )
							return loadRelsOf( self.selectedSpec )
								.done( lDO.resolve )
								.fail( lDO.reject );
						// else
						lDO.resolve()
					})
					.fail( lDo.reject );
			return
		} else {
			lDO.resolve()
		};
		return lDO
	};
*/	self.exportAs = function(opts) {
		if( self.exporting ) return null;
		
		if( !opts ) opts = {};
		if( !opts.format ) opts.format = 'SpecIF';
		// in certain cases, try to export files with the same name in PNG format, as well.
		// - ole: often, preview images are supplied in PNG format;
		// - svg: for generation of DOC or ePub, equivalent images in PNG-format are needed.
		if( !opts.alternatePngFor ) opts.alternatePngFor = ['svg','ole'];	
		
		var eDO = $.Deferred();

			function handleError(xhr) {
				self.exporting = false; 
				eDO.reject(xhr)
			}
		
		if( self.exp ) {
			self.exporting = true;
			// reload the project from the server; the content is collected in myProject:
			self.readContent( 'hierarchy', self.specs, true )	// reload the hierarchies
				.done( function() { 	
					loadFiles()	// reload the files
						.done( function() { 	
							// load referenced objects and relations ... 
							loadAll( 'object' )
								.done( function() { 
									loadAll( 'relation' )
										.done( function() { 	
											// export the project to file:
											switch( opts.format ) {
												case 'SpecIF':
													storeSpecifz();
													break;
												case 'ePub':
													storeEpub()  
											}
										})
										.fail( handleError )
								})
								.fail( handleError )
						})
						.fail( handleError )
				})
				.fail( handleError )
		} else {
			eDO.reject({status: 999, statusText: "No permission to export"})
		};
		return eDO

		function storeEpub( opts ) {
			if( !opts || typeof opts.translateTitles != 'boolean' ) opts = {translateTitles: true};
			var data = specif.get( opts );
			console.debug( "exportAs 'ePub'", data );
			let options = { 
					// If the property titles are translated, then the lists declaring the semantics must, as well:
					headingProperties: opts.translateTitlesOnExport? forAll( CONFIG.headingAttributes, i18n.lookup ) : CONFIG.headingProperties,
					titleProperties: opts.translateTitlesOnExport? forAll( CONFIG.titleAttributes, i18n.lookup ) : CONFIG.titleProperties,
					descriptionProperties: opts.translateTitlesOnExport? forAll( CONFIG.descriptionAttributes, i18n.lookup ) : CONFIG.descriptionProperties,
					// Values of declared stereotypeProperties get enclosed by double-angle quotation mark '&#x00ab;' and '&#x00bb;'
					stereotypeProperties: opts.translateTitlesOnExport? forAll(CONFIG.stereotypeAttributes, i18n.lookup ) : CONFIG.stereotypeAttributes,
					// If a hidden property is defined with value, it is suppressed only if it has this value;
					// if the value is undefined, the property is suppressed in all cases.
					// so far (iLaH v0.92.44), property titles are translated:
					skipProperties: opts.translateTitlesOnExport? [{title:i18n.lookup('SpecIF:Type'),value:'SpecIF:Folder'},{title:i18n.lookup('SpecIF:Type'),value:'Folder'}] : [{title:'SpecIF:Type',value:'SpecIF:Folder'},{title:'SpecIF:Type',value:'Folder'}],
					hideEmptyProperties: true,
					propertiesLabel: opts.translateTitlesOnExport? i18n.lookup('SpecIF:Properties') : 'SpecIF:Properties',
					statementsLabel: opts.translateTitlesOnExport? i18n.lookup('SpecIF:Statements') : 'SpecIF:Statements',
					done: function() { myProject.exporting=false; eDO.resolve() },
					fail: function(xhr) { myProject.exporting=false; eDO.reject(xhr) }
				};
//			console.debug(options);
			toEpub( data, options )
		}
		function storeSpecifz() {
			let zip = new JSZip(),
				i=null, I=null,
				data = specif.get( {translateTitlesOnExport: false} );
				console.debug( "exportAs 'SpecIF'", data );
				let blob = new Blob([JSON.stringify( data )], {type: "text/plain; charset=utf-8"});
				// Add the project:
				zip.file( data.title+".specif", blob );
				blob = null; // free heap space
				
				// Add the files and save all, when done:
//				console.debug('files',data.files);
				for( i=0,I=data.files.length; i<I; i++ ) {
					zip.file( data.files[i].id, data.files[i].blob )
				};
				
				// done, store the specifz:
				zip.generateAsync({
						type: "blob"
					})
					.then(
						function(blob) {
							console.debug("storing ",data.title+".specifz");
							saveAs(blob, data.title+".specifz");
							self.exporting = false;
							eDO.resolve()
					}, 
						function(xhr) {
							console.debug("cannot store ",data.title+".specifz");
							self.exporting = false;
							eDO.reject()
					})
		}
	};
	self.toReqif = function() {
		return specif.toReqif()
	};
	self.abort = function() {
		console.info('abort specif');
		server.abort();
		self.abortFlag = true
	};
	return self

//////////
// some local helper routines:

	function queryObjects( qu, reload ) {   
		// get all the objects of the specified type: qu is {type: specType}
		if( !reload ) {
			// collect all objects with the queried type:
			var oL = forAll( self.objects, function(o) { return o.specType==qu.type?o:null } ),
				dO = $.Deferred();  
			dO.resolve( oL );
			return dO
		};
		// else get them from the server:
	//	return server.project({id: self.id}).objects().read( qu )
		return server.project({id: self.id}).readContent('object',qu)
			.done(function(rsp) {
				cacheL( self.objects, rsp )
			})
	}
	function loadFiles() {
		// in case of ReqIF Server, only a list of file meta data is delivered,
		// whereas in case of PouchDB, the files themselves are delivered.
		return self.readContent( 'file', 'all', true )
	}
	function loadObjsOf( sp ) {
		// Cache all resources=objects referenced in the given spec (hierarchy):
		if( !sp ) { sp = self.selectedSpec };
//		console.debug( 'loadObjsOf', sp );

		var cDO = $.Deferred();

			// is called recursively until the whole list has been processed:
			function loadObjs( oL ) {
				if( !loading && !self.exporting ) { /* console.info('aborting autoLoad'); */ return};  // in case the loading has been stopped (by stopAutoLoad) ...
				// convert list of hierarchy entries to list of objects:
				var rL=[];
				for( var o=oL.length-1;o>-1;o-- ) rL[o] = {id: oL[o]};  
//				return server.project({id: self.id}).objects( rL ).read()
				return server.readContent( 'object', rL )
					.done(function(rsp) {
						// continue caching, if the project hasn't been left, meanwhile:
						if( sp ) {  // sp is null, if the project has been left.
							cacheL( self.objects, rsp );
					
							if( cI<sp.objectRefs.length ) {
								rL = sp.objectRefs.slice(cI,cI+CONFIG.objToGetCount),  // object list; slice just extracts and does not change original list
								cI += rL.length;  // current index
								loadObjs( rL );
								return
							} else {
								cDO.resolve( self.objects );
								return
							}
						}
					})
					.fail( cDO.reject )
			}
		if( sp && sp.objectRefs.length>0 ) {
			var rL = sp.objectRefs.slice(0,CONFIG.objToGetCount),  // object list; slice just extracts and does not change original list
				cI=rL.length;  // current index pointing to start of next batch
			loadObjs( rL )
		} else {
			cDO.resolve([])
		};
		return cDO
	}
	function loadRelsOf( sp ) {
		// Check all referenced resources=objects and get their statements=relations.  Cache the results.  
		// Not efficient, but effective and without alternative in light of the server API.
		if( !sp ) { sp = self.selectedSpec };
//		console.debug( 'loadRelsOf', sp );

		var rDO = $.Deferred();

			// is called recursively until the whole list has been processed:
			function loadRels( ob ) {
				if( !loading && !self.exporting ) { /* console.info('aborting autoLoad'); */ return};  // in case the loading has been stopped (by stopAutoLoad) ...
//				console.debug( 'loadRels', ob );
				self.readRelationsOf( ob )
					.done(function(rsp) {
						// continue caching, if the project hasn't been left, meanwhile (sp==null):
						if( sp && ++cI<sp.objectRefs.length ) {
							loadRels( {id:sp.objectRefs[cI]} )
						} else {
							rDO.resolve( self.relations )
						}
					})
					.fail( rDO.reject )
			}
		if( sp && sp.objectRefs.length && self.relTypes.length>0 ) {
			var cI=0;  // current index
			loadRels( {id:sp.objectRefs[cI]} )
		} else {
			rDO.resolve([])
		};
		return rDO
	}
	function loadAll( ctg ) {
		// Cycle through all hierarchies and load the instances of the specified ctg:
		// The loaded data is cached.
		switch( ctg ) {
			case 'object': 		var fn=loadObjsOf; break;
			case 'relation': 	var fn=loadRelsOf; break;
			default: return null
		};
		var dO = $.Deferred(),
			pend = self.specs.length;
		for( var i=self.specs.length-1; i>-1; i-- ) {
			fn( self.specs[i] )
				.done(function() {
					if(--pend<1) dO.resolve()
				})
				.fail( dO.reject )
		};
		if( self.specs.length<1 ) dO.resolve();
		return dO
	}
	function autoLoad( aU ) {
//		console.debug( 'cache.autoLoad', aU );
		// only update the cache and continue the chain, if autoLoadId of the time of execution is equal to the time of calling (aU):
		if( autoLoadId && aU==autoLoadId ) {
			// Start timer for next update:
			setTimeout( function() { autoLoad( aU ) }, CONFIG.cacheAutoLoadPeriod )
			
			// skip this turn, if autoLoad from last trigger is still being executed (avoid multiple updates in parallel):
			if( loading ) { console.info( 'Skipping autoLoad cycle' ); return };
			// else, start the update:
			loading = true;
			// 1) load the dataTypes:
			self.readContent( 'dataType', [], true )	// true: reload
				.done( function() {
					if( autoLoadId && aU==autoLoadId ) {  // if the update hasn't been stopped, meanwhile
						// 2) load the specTypes:
						self.readContent( 'specType', [], true )
							.done( function() {
								// the new specTypes and the permissions have arrived.
								// 3) update the current spec and the referenced objects:
								if( autoLoadId && aU==autoLoadId )   // if the update hasn't been stopped, meanwhile
									self.loadInstances( autoLoadCb )
							})
							.fail( function(xhr) { 
								loading = false	// e.g. when importing, the calls will fail, but thereafter the autoLoad shall resume.
							})
					}
				})
				.fail( function(xhr) { 
					loading = false	// e.g. when importing, the calls will fail, but thereafter the autoLoad shall resume.
				})
		}
		// else: project has been left or another autoLoad chain has been started, so break this chain.
	}

	function addBaseTypes( item ) {
		if( server.type=='PouchDB' ) return;
		// only needed for ReqIF Server:
		// add base types for easier (context-free) processing of attributes when storing; 
		// for use with createContent and updateContent functions. 
		if( !item || Array.isArray(item)&&item.length<1 ) return;
			function addBT(itm) {
				if( !itm.attributes || itm.attributes.length<1 ) return;
				let sT = itemById( self.specTypes, itm.specType ),aT=null,dT=null;
				for( var a=itm.attributes.length-1; a>-1; a-- ) {
					aT = itemById( sT.attributeTypes, itm.attributes[a].attributeType );
					dT = itemById( self.dataTypes, aT.dataType );
					itm.attributes[a].baseType = dT.type
				}
			}
		if( Array.isArray(item) )
			for(var i=item.length-1;i>-1;i--) addBT(item[i])
		else 
			addBT(item)
	}
	function addPermissions( item ) { 
		// add permissions; 
		// for use with createContent and updateContent functions. 
		// Take the correct permissions from the type:
		if( !item || Array.isArray(item)&&item.length<1 ) return;
			function addPerms( itm ) {
/*				this should be working, but the attributeType's permissions are not available.
				... and if we consider to upgrade the server, we might as well let the instances supply their own permissions - also in responses to an update
				if( itm.specType ) {
					// it is an instance (object, relation or hierarchy):
					let sT = itemById( self.specTypes, itm.specType );
					if( sT ) {
						itm.upd = sT.upd; 
						itm.del = sT.del;
						if( itm.attributes )
							for( var a=itm.attributes.length-1;a>-1;a-- ) {
								// the instance's attributes are sequenced according to the type's attributeTypes:
								itm.attributes[a].upd = sT.attributeTypes[a].upd;
								itm.attributes[a].del = sT.attributeTypes[a].del
							};
						console.debug( 'addPermissions', itm );
						return itm
					} else {
						return null	// should never arrive here
					}
				};
				// else, it must be a specType
*/				// if current user can create an type, he has the other permissions, as well:
				itm.upd=true; 
				itm.del=true;
				if( itm.attributes )
					for( var a=itm.attributes.length-1;a>-1;a-- ) {
						itm.attributes[a].upd=true;
						itm.attributes[a].del=true
					}
			}
		if( Array.isArray(item) )
			for(var i=item.length-1;i>-1;i--) addPerms(item[i])
		else 
			addPerms(item)
	}
	function cache( ctg, item ) { 
		if( !item || Array.isArray(item)&&item.length<1 ) return;
		// If item is a list, all elements are assumed to have the same category (except specType).
		let fn = Array.isArray(item)?cacheL:cacheE;
		switch(ctg) {
			case 'hierarchy':			
			case 'dataType': 			return fn( cacheOf(ctg), item );
			case 'objectType': 
			case 'relationType': 
//			case 'relationGroupType': 
			case 'hierarchyType': 		fn( self.specTypes, item); return fn( cacheOf(ctg), item );
			case 'attributeType':		if(Array.isArray(item)||!item.specType) return null;  // cannot process arrays in this case, yet.
//										console.debug('cache attributeType',item,itemById(self.specTypes,item.specType)); 
										return cacheAtPosition( itemById(self.specTypes,item.specType).attributeTypes, item ); ;
			// in case of RIF, the types are sorted by category upon their first use:
			case 'rifType': 			return fn( self.specTypes, item);
			case 'object': 		
			case 'relation': 	
			case 'file': 				if(self.cacheInstances) return fn( cacheOf(ctg), item );
										else return;
			case 'node':				if(Array.isArray(item)||!item.parent) return null;
										self.selectedSpec.objectRefs.push( item.ref );
//										console.debug('cache',ctg,item);
										return cacheNode( item ); 
			case 'specType':
					// 'specType' is coming from the ReqIF Server; 
					// the elements must be sorted according to their resp. category:
					if( Array.isArray(item) ) {
						// the categories may be mixed, so they are cached one-by-one:
						let done=true;
						for( var i=0,I=item.length; i<I; i++) done &= cache( item[i].category, item[i] );
						return done
					} else {
						return cache( item.category, item )
					};
			default: return null
		}
	}
	function uncache( ctg, item ) { 
			function delNode( L, eId ) {
//				console.debug('delNode',L);
				for( var h=L.length-1;h>-1;h-- ) {
					if( L[h].id==eId ) {
						L.splice(h,1);
						return true
					};
					if( delNode( L[h].children, eId ) ) return true
				};
				return false
			}
		if( !item ) return;
		let fn = Array.isArray(item)?uncacheL:uncacheE;
		switch(ctg) {
			case 'dataType': 			return fn( cacheOf(ctg), item );
			case 'objectType': 	
			case 'relationType': 
//			case 'relationGroupType': 
			case 'hierarchyType': 		fn( self.specTypes, item); return fn( cacheOf(ctg), item );
			case 'attributeType':		let sT = itemById(self.specTypes,item.specType);
//										console.debug('uncache attributeType',item,sT); 
										return fn( sT.attributeTypes, item );
			// no rifType, because we don't allow manipulation on RIF types.
			case 'object': 	
			case 'relation': 			
			case 'file':				if(self.cacheInstances) return fn( cacheOf(ctg), item );
										else return;
			case 'hierarchy':			return fn( self.specs, item );
			case 'node':				if( Array.isArray(item) ) return null;
										removeFromArray( self.selectedSpec.objectRefs, item.ref );
										return delNode( self.specs, item.id );
			default: return null
		}
	}
	function cacheOf( ctg ) {
		// Return the cache for a given category:
		switch(ctg) {
			case 'dataType':		return self.dataTypes;
			case 'objectType':		return self.objTypes;
			case 'relationType':	return self.relTypes;
			case 'hierarchyType':	return self.spcTypes;
			case 'object':			return self.objects;
			case 'relation':		return self.relations;
			case 'hierarchy':		return self.specs;
			case 'file':			return self.files;
			default: return null
		}
	}
	function readCache( ctg, itm, reload ) {
		// Read an item from cache, unless 'reload' is specified:
		if( !reload ) {
			let arr = cacheOf(ctg);
//			console.debug( 'readCache', arr );
			if( itm=='all' ) {
					// return all cached objects asynchronously:
					var dO = $.Deferred();  
//					console.debug( 'readCache', arr, itm );
					dO.resolve( [].concat(arr) );	// return a new list with the original elements
					return dO
			};
			if( Array.isArray(itm) ) {
				let allFound=true, i=0, I=itm.length, idx=null;
				while( allFound && i<I ) {
					idx = indexById( arr, itm[i].id );
					if( idx>-1 )
						itm[i] = arr[idx]
					else
						allFound = false;
					i++
				};
				if( allFound ) {
					// return the cached objects asynchronously:
					var dO = $.Deferred();  
//					console.debug( 'readCache', arr, itm );
					dO.resolve( itm );
					return dO
				}
			} else {
				// is a single item:
				let idx = indexById( arr, itm.id );
				if( idx>-1 ) {
					// return the cached object asynchronously:
					var dO = $.Deferred();  
					dO.resolve( arr[idx] );
//					console.debug('read', ctg, 'from cache:',arr[idx]);
					return dO
				}
			}
		};
		return null
	}
	function cacheNode( e ) {  // ( hierarchy entry )
		// add or replace a node in a hierarchy;
		// e must specify the parent node and optionally a predecessor.
			function findNode( L, eId ) {
//				console.debug('findNode',L);
				let n=null;
				for( var h=L.length-1;h>-1;h-- ) {
					if( L[h].id==eId ) return L[h];
					n = findNode( L[h].children, eId );
					if( n ) return n
				};
				return null
			}
		if( !(e && e.parent) ) return null;
/*		// cycle through all hierarchies and nodes to find the parent:
		let pa = findNode( self.specs, e.parent ); */
		// assuming that nodes are only inserted deleted in the selected hierarchy:
		let pa = findNode( self.selectedSpec.children, e.parent );
//		console.debug('cacheNode',e,pa);
		if( !pa ) return -1;
		if(pa.children==undefined) pa.children = [];
		return cacheAtPosition( pa.children, e )
	}
	function cacheAtPosition( L, e ) {  // ( list, entry )
		// add or update the element e in a list L:
		let n = indexById( L, e.id );
		let p = indexById( L, e.predecessor );
		if( n<0 ) 	{  
			// add, if not yet listed:
			L.splice(++p,0,e);   
//			console.debug('cacheA',p,L);
			return p
		};
		if( n!=p ) {
			// remove existing and add the new element:
			L.splice(n,1);  
			p = indexById( L, e.predecessor );			
			L.splice(++p,0,e);
//			console.debug('cacheA',p,L);
			return p
		};
		// update the existing otherwise:
		L[n] = e; 
		return n 
	}
};   

	var instInfo = {
		// For instances:
		// Pack some additional attributes, which cannot be mapped to ReqIF, into a JSON string, so that it can be stored in the description field. 
		// This is a convention to specify an icon plus the allowed sources and targets per spec-relation-type.
		// ToDo: Define a ReqIF tool-extension, instead.
		fromReqif: function( iE ) {
			function defaultAtts(e) { return { description: e.description || '', changedAt: e.lastChange, changedBy: e.lastChangeBy } }
			if( iE.description && /^{".+}$/.test(iE.description) ) {
//			if( iE.description && iE.description.startsWith('{"') && iE.description.endsWith('}') ) {
				try {
					var cI = JSON.parse( iE.description );
				} catch (e) {
					console.error( 'ERROR: Parsing Optional Info failed:'+ iE.id );
					return defaultAtts(iE);
				};
				let oE = {}; 
				oE.description = cI.description || "";	

				oE.changedAt = cI.changedAt;
				if( cI.changedBy ) oE.changedBy = cI.changedBy;
				if( cI.createdAt ) oE.createdAt = cI.createdAt;
				if( cI.createdBy ) oE.createdBy = cI.createdBy;
				return oE
			};
			return defaultAtts(iE)
		},
		toReqif: function( iE ) {
			let oE = {}; 
			if( iE.description ) oE.description = iE.description;

			oE.changedAt = iE.changedAt;
			if( iE.changedBy ) oE.changedBy = iE.changedBy;
			if( iE.createdAt ) oE.createdAt = iE.createdAt;
			if( iE.createdBy ) oE.createdBy = iE.createdBy;
			return JSON.stringify( oE )		// encode optional information
		}
	};
	var typInfo = {
		// For types:
		// Pack some additional attributes, which cannot be mapped to ReqIF, into a JSON string, so that it can be stored in the description field. 
		// This is a convention to specify an icon plus the allowed sources and targets per spec-relation-type.
		// ToDo: Define a ReqIF tool-extension, instead.
		fromReqif: function( ty, tL ) {
			// Restore the properties from JSON in the description field;
			// tL only needed in case of statementClasses:
			function defaultAtts(e) { return { description: e.description || '', changedAt: e.lastChange, changedBy: e.lastChangeBy } }
			if( ty.description && /^{".+}$/.test(ty.description) ) {
				try {
					var oI = JSON.parse( ty.description );
				} catch (e) {
					console.error( 'ERROR: Parsing Optional Info failed:'+ ty.id );
					return defaultAtts(ty)
				};
				var nT = {};
				let i, I, x;
				nT.description = oI.description || "";	
				if( oI.creation ) 			nT.instantiation = oI.creation;		// deprecated, for compatibility
				if( oI.instantiation ) 		nT.instantiation = oI.instantiation;
				if( nT.instantiation ) 	{
					let idx = nT.instantiation.indexOf('manual');	// deprecated
					if( idx>-1 ) nT.instantiation.splice(idx,1,'user')
				};				
				if( oI.isHeading )			nT.isHeading = oI.isHeading;
				if( oI.icon ) 				nT.icon = oI.icon;
				if( oI.maxLength ) 			nT.maxLength = oI.maxLength;
				if( oI.multiple ) 			nT.multiple = true;
				if( oI.sources && oI.sources.length && tL ) {  
					// only in case of 'SpecRelationType'
					// sources can be IDs or longNames of specObjectTypes. 
					// When 'creating a project from template', the specType identifiers are modified, so better use the longName ....
					nT.sources = oI.sources;   // assume that ty.sources are objType.identifiers
					for( i=0, I=oI.sources.length; i<I; i++) {
						// In the end we want IDs, so replace any longName by it's ID (only if it is a longName ;-)
						x = indexByName( tL, oI.sources[i] );
						if( x>-1 ) nT.sources[i] = tL[x].id
					}
				};
				if( oI.targets && oI.targets.length && tL ) {
					// only in case of 'SpecRelationType'
					// process similarly to sources
					nT.targets = oI.targets;
					for( i=0, I=oI.targets.length; i<I; i++) {
						x = indexByName( tL, oI.targets[i] );
						if( x>-1 ) nT.targets[i] = tL[x].id
					}
				};

				nT.changedAt = oI.changedAt;
				if( oI.changedBy ) nT.changedBy = oI.changedBy;
				if( oI.createdAt ) nT.createdAt = oI.createdAt;
				if( oI.createdBy ) nT.createdBy = oI.createdBy;
				return nT
			};
			// general case without optional information:
			return defaultAtts(ty)
		},
		toReqif: function( ty ) {
			// Store the properties as JSON in the description field:
			let oI = {}; 
			if( ty.description ) 					oI.description = ty.description;
			if( ty.icon ) 							oI.icon = ty.icon;
			if( ty.maxLength ) 						oI.maxLength = ty.maxLength;
			if( ty.instantiation ) 					oI.instantiation = ty.instantiation;
			if( ty.isHeading ) 						oI.isHeading = ty.isHeading;
			// create source resp. target lists only if they have at least one value:
			// 'no list' means that all types are permissible.
			if( ty.sources && ty.sources.length ) 	oI.sources = ty.sources;
			if( ty.targets && ty.targets.length ) 	oI.targets = ty.targets;
			if( ty.multiple ) 						oI.multiple = true;

			oI.changedAt = ty.changedAt;
			if( ty.changedBy ) oI.changedBy = ty.changedBy;
			if( ty.createdAt ) oI.createdAt = ty.createdAt;
			if( ty.createdBy ) oI.createdBy = ty.createdBy;
			return JSON.stringify( oI )		// encode optional information
		}
	};

//    Especially OLE-Objects from DOORS are coming in this format; the outer object is the OLE, the inner is the preview image.
//    The inner object can be a tag pair <object .. >....</object> or comprehensive tag <object .. />.
//		Sample data from french branch of a japanese car OEM:
//			<object data=\"OLE_AB_4b448d054fad33a1_23_2100028c0d_28000001c9__2bb521e3-8a8c-484d-988a-62f532b73612_OBJECTTEXT_0.ole\" type=\"text/rtf\">
//				<object data=\"OLE_AB_4b448d054fad33a1_23_2100028c0d_28000001c9__2bb521e3-8a8c-484d-988a-62f532b73612_OBJECTTEXT_0.png\" type=\"image/png\">OLE Object</object>
//			</object>
//		Sample data from ReX:
//			<object data=\"Tabelle mit WordPics_Partner1/4_Object_Text_0.ole\" type=\"application/oleobject\">\n   
//				<object data=\"Tabelle mit WordPics_Partner1/4_Object_Text_0.png\" type=\"image/png\">OLE Object</object>\n 
//			</object>
//		Sample from ProSTEP ReqIF Implementation Guide:
//			<xhtml:object data="files/powerpoint.rtf" height="96" type="application/rtf" width="96">
//				<xhtml:object data="files/powerpoint.png" height="96" type="image/png" 	width="96">
//					This text is shown if alternative image can't be shown
//				</xhtml:object>
//			</xhtml:object>
RE.tagNestedObjects = new RegExp( '<object([^>]+)>[\\s\\S]*?<object([^>]+)(\/>|>([\\s\\S]*?)<\/object>)[\\s\\S]*?<\/object>', 'g' );
//      For example, the ARCWAY Cockpit export uses this pattern:
//			<object data=\"files_and_images\\27420ffc0000c3a8013ab527ca1b71f5.svg\" name=\"27420ffc0000c3a8013ab527ca1b71f5.svg\" type=\"image/svg+xml\"/>
//			<object data=\"files_and_images\\27420ffc0000c3a8013ab527ca1b71f5.svg\" type=\"image/svg+xml\">27420ffc0000c3a8013ab527ca1b71f5.svg</object>
RE.tagSingleObject = new RegExp( '<object([^>]+)(\/>|>([\\s\\S]*?)<\/object>)', 'g' );
RE.tagA = new RegExp( '<a([^>]+)>([\\s\\S]*?)<\/a>', 'g' );

// Transform SpecIF data to internal data structures ... and vice-versa:
function Specif( pr ) {
	"use strict";
	var self = this;
//	self.open = function() {
//	};
//	self.close = function() {
//	};

	var dataType = {
		toSpecif: function( iE ) {
			var oE = {
				id: iE.id,
				title: iE.longName
			};
			if( iE.description ) oE.description = iE.description;
			switch( iE.type ) {
				case "STRING":		oE.type = "xs:string";
									oE.maxLength = iE.maxLength || CONFIG.maxStringLength;
									break;
				case "XHTML": 		oE.type = "xhtml";
									oE.maxLength = iE.maxLength || CONFIG.maxStringLength;
									break;
				case "ENUMERATION": oE.type = "xs:enumeration";
									oE.values = iE.values;
									if( iE.multiple ) oE.multiple = true;
									break;
				case "BOOLEAN": 	oE.type = "xs:boolean";
									break;
				case "INTEGER": 	oE.type = "xs:integer";
									oE.min = iE.min;
									oE.max = iE.max;
									break;
				case "REAL": 		oE.type = "xs:double";
									oE.accuracy = iE.accuracy;
									oE.min = iE.min;
									oE.max = iE.max;
									break;
				case "DATETIME": 	oE.type = "xs:dateTime";
			};
			if( iE.revision ) oE.revision = iE.revision;
			oE.changedAt = iE.changedAt;
			if( iE.changedBy ) oE.changedBy = iE.changedBy;
//			if( iE.createdAt ) oE.createdAt = iE.createdAt;
//			if( iE.createdBy ) oE.createdBy = iE.createdBy;
//			console.debug('dataType.toSpecif',iE,oE);
			return oE
		},
		fromSpecif: function( iE ) {
			var oE = {
				id: iE.id,
				longName: iE.title,
				category: 'dataType'
			};
			if( iE.description ) oE.description = iE.description;
			switch( iE.type ) {
				case "xs:string": 		oE.type = "STRING";	
										oE.maxLength = iE.maxLength || CONFIG.maxStringLength;
										break;
				case "xhtml": 			oE.type = "XHTML";
										oE.maxLength = iE.maxLength || CONFIG.maxStringLength;
										break;
				case "xs:enumeration": 	oE.type = "ENUMERATION";
										oE.values = iE.values?iE.values:[];
										if( iE.multiple ) oE.multiple = true;
										break;
				case "xs:boolean": 		oE.type = "BOOLEAN";
										break;
				case "xs:integer": 		oE.type = "INTEGER";
										oE.min = iE.min;
										oE.max = iE.max;
										break;
				case "xs:double": 		oE.type = "REAL";
										oE.accuracy = iE.accuracy;
										oE.min = iE.min;
										oE.max = iE.max;
										break;
				case "xs:dateTime": 	oE.type = "DATETIME";
			};
			if( iE.revision ) oE.revision = iE.revision;
			oE.changedAt = iE.changedAt;
			if( iE.changedBy ) oE.changedBy = iE.changedBy;
//			if( iE.createdAt ) oE.createdAt = iE.createdAt;
//			if( iE.createdBy ) oE.createdBy = iE.createdBy;
//			console.debug('dataType.fromSpecif',iE,oE);
			return oE
		}
	};
	var propClass = {
		toSpecif: function( iE ) {
			var oE = {
				id: iE.id,
				title: self.options.translateTitles? titleOf(iE) : iE.longName		
			};
			if( iE.description ) oE.description = iE.description;
			oE.dataType = iE.dataType;
			let dT = itemById( pr.dataTypes, iE.dataType );
			switch( dT.type ) {
				case 'ENUMERATION': 
					// With SpecIF, he 'multiple' property should be defined at dataType level and can be overridden at propertyType level.
					// 	dT.multiple 	aTs.multiple 	aTs.multiple	effect
					// ---------------------------------------------------------
					//	undefined		undefined 		undefined		false
					//	false			undefined		undefined		false
					//	true			undefined		undefined		true
					//	undefined		false			undefined		false
					//	false			false			undefined		false
					//	true 			false			false			false
					//	undefined		true 			true			true
					//	false			true 			true			true
					//	true 			true 			undefined		true
					// Include the property only, if is different from the dataType's:
					if( iE.multiple && !dT.multiple ) oE.multiple = true
					else if( iE.multiple==false && dT.multiple ) oE.multiple = false
			};
			if( iE.revision ) oE.revision = iE.revision;
			oE.changedAt = iE.changedAt;
			if( iE.changedBy ) oE.changedBy = iE.changedBy;
			return oE
		},
		fromSpecif: function( iE ) {
			var oE = {
				id: iE.id,
				longName: vocabulary.property.specif(noCode(iE.title))	// an input file may have longNames which are not from the SpecIF vocabulary.
			};
			if( iE.description ) oE.description = noCode(iE.description);
			oE.dataType = iE.dataType;
			let dT = itemById( self.value.dataTypes, iE.dataType );
			switch( dT.type ) {
				case 'ENUMERATION': 
					// include the property only, if is different from the dataType's:
					if( iE.multiple && !dT.multiple ) oE.multiple = true
					else if( iE.multiple==false && dT.multiple ) oE.multiple = false
			};
			if( iE.revision ) oE.revision = iE.revision;
			oE.changedAt = iE.changedAt;
			if( iE.changedBy ) oE.changedBy = iE.changedBy;
//			console.debug('propClass.fromSpecif',iE,oE);
			return oE
		}
	};
	var specType = {
		// common for all types
		toSpecif: function( iE ) {
			var oE = {
				id: iE.id,
				title: self.options.translateTitles? titleOf(iE) : iE.longName		
			};
			if( iE.description ) oE.description = iE.description;
			if( iE.icon ) oE.icon = iE.icon;
			if( iE.instantiation ) oE.instantiation = iE.instantiation;
			let aTs = forAll( iE.attributeTypes, propClass.toSpecif );
			if( aTs.length>0 ) oE.propertyClasses = aTs;
			if( iE.revision ) oE.revision = iE.revision;
			oE.changedAt = iE.changedAt;
			if( iE.changedBy ) oE.changedBy = iE.changedBy;
//			if( iE.createdAt ) oE.createdAt = iE.createdAt;
//			if( iE.createdBy ) oE.createdBy = iE.createdBy;
			return oE
		},
		fromSpecif: function( iE ) {
			var oE = {
				id: iE.id,
				longName: vocabulary.resource.specif(noCode(iE.title))
			};
			if( iE.description ) oE.description = noCode(iE.description);
			if( iE.icon ) oE.icon = iE.icon;
			if( iE.creation ) oE.instantiation = iE.creation;	// deprecated, for compatibility
			if( iE.instantiation ) oE.instantiation = iE.instantiation;
			if( oE.instantiation ) 	{
				let idx = oE.instantiation.indexOf('manual');	// deprecated
				if( idx>-1 ) oE.instantiation.splice(idx,1,'user')
			};				
			oE.attributeTypes = forAll( iE[names.pClasses], propClass.fromSpecif );
			if( iE.revision ) oE.revision = iE.revision;
			oE.changedAt = iE.changedAt;
			if( iE.changedBy ) oE.changedBy = iE.changedBy;
//			if( iE.createdAt ) oE.createdAt = iE.createdAt;
//			if( iE.createdBy ) oE.createdBy = iE.createdBy;
//			console.debug('specType',oE);
			return oE
		}
	};
	var resourceClass = {
		toSpecif: function( iE ) {
			var oE = specType.toSpecif( iE );

			// Include "isHeading" in SpecIF only if true:
			if( iE.isHeading ) oE.isHeading = true;
			return oE
		},
		fromSpecif: function( iE ) {
			var oE = specType.fromSpecif( iE );
			oE.category = 'objectType';

			// If "iE.isHeading" is defined, use it:
			if( iE.isHeading != undefined ) {
				oE.isHeading = iE.isHeading;
				return oE
			};
			// else: take care of older data without "isHeading":
			if( iE.title=='SpecIF:Heading' ) {
				oE.isHeading = true;
				return oE
			};
			// else: look for an attributeType being configured in CONFIG.headingAttributes
			oE.isHeading = false;
//			var idx = -1;
//			for( var c=0, C=CONFIG.headingAttributes.length; c<C; c++) {  // iterate configuration list; leading entry has priority
//				idx = indexByName( oE.attributeTypes, CONFIG.headingAttributes[c] );
//				if( idx>-1 ) {
			for( var a=oE.attributeTypes.length-1;a>-1;a--) {
				if( CONFIG.headingAttributes.indexOf( oE.attributeTypes[a].title )>-1 ) {
					oE.isHeading = true;
					break
				}
			};
//			console.debug('resourceClass.fromSpecif',iE,oE);
			return oE
		}
	};
	var statementClass = {
		toSpecif: function( iE ) {
			var oE = specType.toSpecif( iE );
			if( iE.sources ) oE.subjectClasses = iE.sources;
			if( iE.targets ) oE.objectClasses = iE.targets;
			return oE
		},
		fromSpecif: function( iE ) {
//			console.debug('statementClass.fromSpecif',iE.title);
			var oE = specType.fromSpecif( iE );
			oE.category = 'relationType';
			if( iE[names.subClasses] ) oE.sources = iE[names.subClasses];
			if( iE[names.objClasses] ) oE.targets = iE[names.objClasses];
//			console.debug('statementClass.fromSpecif',iE,oE);
			return oE
		}
	};
	var hierarchyClass = {
		toSpecif: function( iE ) {
			var oE = specType.toSpecif( iE );
			return oE
		},
		fromSpecif: function( iE ) {
			var oE = specType.fromSpecif( iE );
			oE.category = 'hierarchyType';
//			console.debug('fromSpecif.hierarchyClass',iE,oE);
			return oE
		}
	};
	var propValue = {
		toSpecif: function( iE ) {
			if( !iE.content ) return null;	// skip empty attributes
			var oE = {
				// no id
				// internally only valid SpecIF terms are used (hope so ;-)
				title: self.options.translateTitles? titleOf(iE) : iE.longName		
			};
			oE['class'] = iE.attributeType;
			if( iE.description ) oE.description = iE.description;
			
/*			// List all referenced files.
			// This is however not sufficient, because SVG-files may reference pixel-based images
			// stored in separate files.
			if( /<object([^>]+)\/>/.test( iE.content ) )
				console.debug( '*', iE.longName, iE.content );
			if( CONFIG.descriptionAttributes.indexOf(iE.longName)>-1 ) {
				// identify referenced files and list them:
				let o = RE.tagSingleObject.exec( iE.content ); 
//				let o = /<object([^>]+)(\/>|>([^<]*?)<\/object>)/g.exec( iE.content );
				if( o && o.length>2 ) {
					cacheE( self.files, {
						id: getUrl( o[1] ).replace('\\','/'),  // is the distinguishing/relative part of the URL
						title: (o[3] || getName( o[1] )).replace('\\','/'),
						type: getType( o[1] )
					})
				}
			};
*/			
			// according to the schema, all property values are represented as string:
			switch( typeof iE.content ) {
				case 'boolean':
					oE.value = bool.toString(iE.content);
					break;
				case 'number':
					oE.value = num.toString(iE.content);
					break;
				default:
					oE.value = iE.content
			};
			// properties do not have their own revision and change info; the parent's apply.
			return oE

			function getType( str ) {
				var t = /type="([^"]+)"/.exec( str );
				if( t==null ) return '';
				return t[1]
			}
			function getName( str ) {
				var n = /name="([^"]+)"/.exec( str );
				if( n==null ) return '';
				return n[1]
			}
			function getUrl( str ) {
				// get the URL:
				var l = /data="([^"]+)"/.exec( str );  // url in l[1]
				// return null, because an URL is expected in any case:
				if( l==null ) return null;    
				return l[1]
			}
		},
		fromSpecif: function( iE ) {
//			console.debug('propValue.fromSpecif',iE);
			let pT = anyPropTypeById( iE[names.pClass] ),
				dT = itemById( self.value.dataTypes, pT.dataType );
			var oE = {
				// no id
				longName: vocabulary.property.specif(noCode(iE.title || pT.title)),	// an input file may have longNames which are not from the SpecIF vocabulary.
				attributeType: iE[names.pClass]
			};
			if( iE.description ) oE.description = noCode(iE.description);
			switch( dT.type ) {
				case 'xs.boolean':
					oE.content = iE.value=='true';
					break;
				case 'xs.integer':
					oE.content = parseInt(iE.value,10);
					break;
				case 'xs.double':
					oE.content = parseFloat(iE.value);
					break;
				default:
					oE.content = noCode(iE.value)
			};
			// sub-elements do not have their own revision and change info
//			console.debug('propValue.fromSpecif',iE,pT,oE);
			return oE
		}
	};
	var instance = {
		toSpecif: function( iE ) {
			var oE = {
				id: iE.id,
				// resources and hierarchies usually have individual titles, and so we will not translate:
				title: objTitleOf( iE )
			};
			if( iE.description ) oE.description = iE.description;
			oE['class'] = iE.specType;
			let aL = forAll( iE.attributes, propValue.toSpecif );
			if( aL.length>0 ) oE.properties = aL;
			if( iE.revision ) oE.revision = iE.revision;
			oE.changedAt = iE.changedAt;
			if( iE.changedBy ) oE.changedBy = iE.changedBy;
//			if( iE.createdAt ) oE.createdAt = iE.createdAt;
//			if( iE.createdBy ) oE.createdBy = iE.createdBy;
			return oE
		},
		fromSpecif: function( iE ) {
//			console.debug('instance.fromSpecif',iE);
			// attributes of hierarchy roots are not yet supported, so use longName and description
			var oE = {
				id: iE.id,
				longName: noCode(iE.title)
			};
			if( iE.description ) oE.description = noCode(iE.description);
			oE.attributes = forAll( iE.properties, propValue.fromSpecif );

			if( iE.revision ) oE.revision = iE.revision;
			oE.changedAt = iE.changedAt;
			if( iE.changedBy ) oE.changedBy = iE.changedBy;
//			if( iE.createdAt ) oE.createdAt = iE.createdAt;
//			if( iE.createdBy ) oE.createdBy = iE.createdBy;
//			console.debug('instance.fromSpecif',iE,oE);
			return oE
		}
	};
	var resource = {
		toSpecif: function( iE ) {
			var oE = instance.toSpecif( iE );
//			console.debug('resource.fromSpecif',iE,oE);
			return oE
		},
		fromSpecif: function( iE ) {
//			console.debug('resource.fromSpecif',iE.title);
			var oE = instance.fromSpecif( iE );
			oE.specType = iE[names.rClass];
//			console.debug('resource.fromSpecif',iE,oE);
			return oE
		}
	};
	var statement = {
		toSpecif: function( iE ) {
//			console.debug('statement.toSpecif',iE.longName);
			if( CONFIG.hiddenRelations.indexOf( iE.longName )>-1 ) return null;  // do not export invisible statements
			var oE = instance.toSpecif( iE );
			// The statements usually do use a vocabulary item (and not have an individual title), 
			// so we translate, if so desired, e.g. when exporting to ePub:
			// ToDo: Take the title from statement properties, if provided (similarly to resources).
			// Take the statementClass's title, if the statement does not have it:
			iE.longName = iE.longName || itemById( pr.relTypes, iE.specType ).longName;
			oE.title = self.options.translateTitles? titleOf(iE) : iE.longName;
			oE.subject = iE.source.id;
			oE.object = iE.target.id;
			return oE
		},
		fromSpecif: function( iE ) {
//			console.debug('statement.fromSpecif',iE.title);
			var oE = instance.fromSpecif( iE );
			oE.longName = itemById( self.value[names.sClasses], iE[names.sClass] ).title;
			oE.specType = iE[names.sClass];
//			oE.source = {id: iE.subject, revision: 0};
//			oE.target = {id: iE.object, revision: 0};
			// SpecIF allows subjects and objects with id (v0.10.2) or with id+revision (v0.11.1),
			// so normalize internally to id+revision:
			switch( typeof iE.subject ) {
				case "object": oE.source = iE.subject; break;				// iE is SpecIF 0.11.1
				case "string": oE.source = {id: iE.subject, revision: 0}	// iE is SpecIF 0.10.2
			};
			switch( typeof iE.object ) {
				case "object": oE.target = iE.object; break;			
				case "string": oE.target = {id: iE.object, revision: 0} 
			};
//			console.debug('statement.fromSpecif',iE,oE);
			return oE
		}
	};
	var hierarchy = {
		toSpecif: function( iE ) {
				function entry( iE ) {
					var oE = {
						id: iE.id,
//						title: iE.name,   // no need for 'title' in SpecIF ... it is redundant
						resource: iE.ref
					};
					// avoid empty node lists:
					var nds = forAll( iE.children, entry );
					if( nds.length>0 )  oE.nodes = nds;
					if( iE.revision ) oE.revision = iE.revision;
					oE.changedAt = iE.changedAt;
					return oE
				};
			var oE = instance.toSpecif( iE );
			oE.nodes = forAll( iE.children, entry );
//			console.debug('hierarchy.fromSpecif',iE,oE);
			return oE
		},
		fromSpecif: function( iE ) {
				function entry( iE ) {
					var oE = {
						id: iE.id,
						// take the referenced resource's title:
						name: itemById( self.value.resources, iE.resource ).title, // 'name' is used by jqTree.
//						ref: typeof iE.resource=='string'?iE.resource:iE.resource.id 
						ref: iE.resource	// for SpecIF 10.x.
					};
					oE.children = forAll( iE.nodes, entry );
					if( iE.revision ) oE.revision = iE.revision;
					oE.changedAt = iE.changedAt;
					return oE
				};
			var oE = instance.fromSpecif( iE );
			oE.specType = iE[names.hClass];
			oE.children = forAll( iE.nodes, entry );
//			console.debug('hierarchy.fromSpecif',iE,oE);
			return oE
		}
	};
	var file = {
		toSpecif: function( iE ) {
			var oE = {
				id: iE.id,  // is the distinguishing/relative part of the URL
//				title: ,
				type: iE.type
			};
			if( iE.blob ) oE.blob = iE.blob;
			return oE
		},
		fromSpecif: function( iE ) {
			var oE = iE;
			if( iE.blob ) oE.type = iE.blob.type || iE.type || attachment2mediaType( iE.id );
			return oE
		}
	};

	self.get = function( opts ) {
		// the current content of pr (in internal data format) is 
		// - transformed to SpecIF
		// - stored in self.value
		// - returned asynchronously
		if( opts ) {
			if( typeof opts.translateTitles!='boolean' ) opts.translateTitles = false
		} else {
			opts = {
				translateTitles: false
			}
		};
		self.options = opts;
		
		// transform internal data to SpecIF:
//		var sDO = $.Deferred();
		self.value = {
				id: pr.id,
				title: pr.title
			};
		if( pr.description ) self.value.description = pr.description;
		self.value.specifVersion = CONFIG.specifVersion;
		self.value.generator = CONFIG.productTitle;
		self.value.generatorVersion = CONFIG.productVersion;
		self.value.rights = {
			title: "Creative Commons 4.0 CC BY-SA",
			type: "dcterms:rights",
			url: "https://creativecommons.org/licenses/by-sa/4.0/"
		};
		self.value.createdAt = new Date().toISOString();
		self.value.createdBy = {
			familyName: userProfile.lastName, 
			givenName: userProfile.firstName, 
			org: {organizationName: userProfile.organization}, 
			email: {type:"text/html",value:userProfile.email}
		};
		self.value.dataTypes = forAll( pr.dataTypes, dataType.toSpecif );
		self.value.resourceClasses = forAll( pr.objTypes, resourceClass.toSpecif );
		self.value.statementClasses = forAll( pr.relTypes, statementClass.toSpecif );
		self.value.hierarchyClasses = forAll( pr.spcTypes, hierarchyClass.toSpecif );
		self.value.resources = forAll( pr.objects, resource.toSpecif );
		self.value.statements = forAll( pr.relations, statement.toSpecif );
		self.value.hierarchies = forAll( pr.specs, hierarchy.toSpecif );
		self.value.files = forAll( pr.files, file.toSpecif );
		// ToDo: schema and consistency check (if we want to detect any programming errors)
//		console.debug('specif.get done',self.value);
//		sDO.resolve( self.value );
//		return sDO
		return self.value
	};
	
	var names = {};
	self.put = function( iE ) {
		// transform SpecIF to internal data:
		// ToDo: schema and consistency check
		self.value = iE;	// temporary storage for transformation

		switch( iE.specifVersion ) {
			case '0.10.2':
			case '0.10.3':
				names.rClasses = 'resourceTypes';
				names.sClasses = 'statementTypes';
				names.hClasses = 'hierarchyTypes';
				names.pClasses = 'propertyTypes';
				names.subClasses = 'subjectTypes';
				names.objClasses = 'objectTypes';
				names.rClass = 'resourceType';				
				names.sClass = 'statementType';
				names.hClass = 'hierarchyType';
				names.pClass = 'propertyType';
				break;
			default:
				names.rClasses = 'resourceClasses';
				names.sClasses = 'statementClasses';
				names.hClasses = 'hierarchyClasses';
				names.pClasses = 'propertyClasses';
				names.subClasses = 'subjectClasses';
				names.objClasses = 'objectClasses';
				names.rClass = 'class';
				names.sClass = 'class';
				names.hClass = 'class';
				names.pClass = 'class'
		};
		var oE = {};
		try {
			oE = {
				dataTypes: 	forAll( iE.dataTypes, dataType.fromSpecif ),
				objTypes: 	forAll( iE[names.rClasses], resourceClass.fromSpecif ),
				relTypes:	forAll( iE[names.sClasses], statementClass.fromSpecif ),
				spcTypes:	forAll( iE[names.hClasses], hierarchyClass.fromSpecif ),
				objects: 	forAll( iE.resources, resource.fromSpecif ),
				relations:	forAll( iE.statements, statement.fromSpecif ),
				specs:		forAll( iE.hierarchies, hierarchy.fromSpecif ),
				files:		forAll( iE.files, file.fromSpecif )
			}
		} catch (e) {
			console.error( "Error when importing the project '"+iE.title+"'" );
			message.show( i18n.phrase( 'MsgImportFailed', iE.title ), 'error', CONFIG.messageDisplayTimeNormal );
			return null
		};
		// header information provided only in case of project creation, but not in case of project update:
		if( iE.id ) oE.id = iE.id;
		if( iE.title ) oE.title = iE.title;
		if( iE.description ) oE.description = iE.description;
		if( iE.generator ) oE.tool = iE.generator;
//		self.value = null;
//		console.debug('specif.put',oE);
		return oE
	};
	self.check = function( data ) {
		// check the SpecIF data;
		// neither self.value, nor pr are changed:
		var cDO = $.Deferred();
		// 1. Validate the data using the SpecIF schema:
		cDO.notify('Checking schema',10);

		// Get the specified schema file from the server:
		get( 
			"https://specif.de/v"+data.specifVersion+"/schema", 
			'arraybuffer',	// response type
			false,	// no credentials
			function(xhr) { 
//				console.debug('schema', xhr);
				switch( xhr.status ) {
					case 200:
						// 1. check data against schema:
						let rc = checkSchema( JSON.parse( buf2str(xhr.response) ), data );
						if( rc.status!=0 ) { cDO.reject( rc ); return };

						// 2. Check further constraints:
						cDO.notify('Checking constraints',20);
						rc = checkConstraints( data );
						if( rc.status==0 ) 	cDO.resolve( data, rc )
						else 				cDO.reject( rc );
						break
					case 404:
						xhr = { status: 903, statusText: 'SpecIF version '+data.specifVersion+' is not supported by the program!' };
					default:
						cDO.reject(xhr)
				}
			}, 
			null
		);
		return cDO
	};
	self.toReqif = function() {
		// transform internal data to ReqIF:
		let date = new Date().toISOString(),
			i, I, el;

		var xml = 
			'<?xml version="1.0" encoding="UTF-8"?>' +
			'<REQ-IF xmlns="http://www.omg.org/spec/ReqIF/20110401/reqif.xsd" xmlns:xhtml="http://www.w3.org/1999/xhtml">' +
			'<THE-HEADER>' +
			  '<REQ-IF-HEADER IDENTIFIER="'+pr.id+'">' +
				'<COMMENT>'+(pr.description || '')+'</COMMENT>' +
				'<CREATION-TIME>'+date+'</CREATION-TIME>' +
				'<REQ-IF-TOOL-ID></REQ-IF-TOOL-ID>' +
				'<REQ-IF-VERSION>1.0</REQ-IF-VERSION>' +
				'<SOURCE-TOOL-ID>'+(pr.tool || '')+'</SOURCE-TOOL-ID>' +
				'<TITLE>'+pr.title+'</TITLE>' +
			  '</REQ-IF-HEADER>' +
			'</THE-HEADER>' +
			'<CORE-CONTENT>' +
			  '<REQ-IF-CONTENT>' +
				'<DATATYPES>';
		if(pr.dataTypes)	
			for( i=0, I=pr.dataTypes.length; i<I; i++ ) {
				el = pr.dataTypes[i];
				switch( el.type ) {
					case 'BOOLEAN':
						xml += '<DATATYPE-DEFINITION-BOOLEAN '+commonAtts( el )+'/>';
						break;
					case 'INTEGER':
						xml += '<DATATYPE-DEFINITION-INTEGER '+commonAtts( el )+' MAX="'+el.max+'" MIN="'+el.min+'" />';
						break;
					case 'REAL':
						xml += '<DATATYPE-DEFINITION-REAL '+commonAtts( el )+' MAX="'+el.max+'" MIN="'+el.min+'" ACCURACY="'+el.accuracy+'" />';
						break;
					case 'STRING':
						xml += '<DATATYPE-DEFINITION-STRING '+commonAtts( el )+' MAX-LENGTH="'+el.maxLength+'" />';
						break;
					case 'XHTML':
						xml += '<DATATYPE-DEFINITION-XHTML '+commonAtts( el )+'/>';
						break;
					case 'ENUMERATION':
						xml += '<DATATYPE-DEFINITION-ENUMERATION '+commonAtts( el )+'>' +
								'<SPECIFIED-VALUES>';
						for( var v=0,V=el.values.length;v<V;v++ ) {
							xml += '<ENUM-VALUE IDENTIFIER="'+el.values[v].id+'" LONG-NAME="'+el.values[v].title+'" LAST-CHANGE="'+dateTime(el)+'" >' +
									 '<PROPERTIES><EMBEDDED-VALUE KEY="'+v+'" OTHER-CONTENT="" /></PROPERTIES>' +
								   '</ENUM-VALUE>';
						};
						xml += 	'</SPECIFIED-VALUES>' +
								'</DATATYPE-DEFINITION-ENUMERATION>';
						break;
					case 'DATETIME':
						xml += '<DATATYPE-DEFINITION-DATE '+commonAtts( el )+'/>';
						break;
				}
			};
		xml +=  '</DATATYPES>' +
				'<SPEC-TYPES>';
		if(pr.objTypes)	
			for( i=0, I=pr.objTypes.length; i<I; i++ ) {
				el = pr.objTypes[i];
				xml += '<SPEC-OBJECT-TYPE '+commonAtts( el )+'>' +
							attrTypes( el.attributeTypes ) +
				      '</SPEC-OBJECT-TYPE>';
			};
		if(pr.relTypes)	
			for( i=0, I=pr.relTypes.length; i<I; i++ ) {
				el = pr.relTypes[i];
				xml += '<SPEC-RELATION-TYPE '+commonAtts( el )+'>' +
							attrTypes( el.attributeTypes ) +
				      '</SPEC-RELATION-TYPE>';
			};
		if(pr.spcTypes)	
			for( i=0, I=pr.spcTypes.length; i<I; i++ ) {
				el = pr.spcTypes[i];
				xml += '<SPECIFICATION-TYPE '+commonAtts( el )+'>' +
							attrTypes( el.attributeTypes ) +
				      '</SPECIFICATION-TYPE>';
			};
		xml +=  '</SPEC-TYPES>' +
				'<SPEC-OBJECTS></SPEC-OBJECTS>' +
				'<SPEC-RELATIONS></SPEC-RELATIONS>' +
				'<SPECIFICATIONS></SPECIFICATIONS>' +
				'<SPEC-RELATION-GROUPS></SPEC-RELATION-GROUPS>' +
			  '</REQ-IF-CONTENT>' +
			'</CORE-CONTENT>' +
			'<TOOL-EXTENSIONS></TOOL-EXTENSIONS>' +
			'</REQ-IF>';
/*		let blob = new Blob([xml], {type: "text/plain; charset=utf-8"});
		// save to file using fileSaver.js:
		saveAs(blob, "debug.reqif", true);		// true: no_auto_bom, i.e. suppress EF BB BF at the beginning of the file
		console.debug('reqif',xml);
*/		return xml

			function dateTime( e ) {
				return e.changedAt || pr.changedAt || date
			}
			function commonAtts( e ) {
				return 'IDENTIFIER="'+e.id+'" LONG-NAME="'+e.longName+'" DESC="'+typInfo.toReqif(e).escapeXML()+'" LAST-CHANGE="'+dateTime(e)+'"'
			}
			function attrTypes( at ) {
				if( !at ) return '';
				var xml='<SPEC-ATTRIBUTES>';
				for( var j=0, J=at.length; j<J; j++ ) {
					switch( itemById( pr.dataTypes, at[j].dataType ).type ) {
						case 'BOOLEAN':
							xml += 	'<ATTRIBUTE-DEFINITION-BOOLEAN IDENTIFIER="'+at[j].id+'" LONG-NAME="'+vocabulary.property.reqif(at[j].longName)+'" LAST-CHANGE="'+dateTime(at[j])+'">' +
										'<TYPE><DATATYPE-DEFINITION-BOOLEAN-REF>'+at[j].dataType+'</DATATYPE-DEFINITION-BOOLEAN-REF></TYPE>' +
									'</ATTRIBUTE-DEFINITION-BOOLEAN>'
							break;
						case 'INTEGER':
							xml += 	'<ATTRIBUTE-DEFINITION-INTEGER IDENTIFIER="'+at[j].id+'" LONG-NAME="'+vocabulary.property.reqif(at[j].longName)+'" LAST-CHANGE="'+dateTime(at[j])+'">' +
										'<TYPE><DATATYPE-DEFINITION-INTEGER-REF>'+at[j].dataType+'</DATATYPE-DEFINITION-INTEGER-REF></TYPE>' +
									'</ATTRIBUTE-DEFINITION-INTEGER>'
							break;
						case 'REAL':
							xml += 	'<ATTRIBUTE-DEFINITION-REAL IDENTIFIER="'+at[j].id+'" LONG-NAME="'+vocabulary.property.reqif(at[j].longName)+'" LAST-CHANGE="'+dateTime(at[j])+'">' +
										'<TYPE><DATATYPE-DEFINITION-REAL-REF>'+at[j].dataType+'</DATATYPE-DEFINITION-REAL-REF></TYPE>' +
									'</ATTRIBUTE-DEFINITION-REAL>'
							break;
						case 'STRING':
							xml += 	'<ATTRIBUTE-DEFINITION-STRING IDENTIFIER="'+at[j].id+'" LONG-NAME="'+vocabulary.property.reqif(at[j].longName)+'" LAST-CHANGE="'+dateTime(at[j])+'">' +
										'<TYPE><DATATYPE-DEFINITION-STRING-REF>'+at[j].dataType+'</DATATYPE-DEFINITION-STRING-REF></TYPE>' +
									'</ATTRIBUTE-DEFINITION-STRING>'
							break;
						case 'XHTML':
							xml += 	'<ATTRIBUTE-DEFINITION-XHTML IDENTIFIER="'+at[j].id+'" LONG-NAME="'+vocabulary.property.reqif(at[j].longName)+'" LAST-CHANGE="'+dateTime(at[j])+'">' +
										'<TYPE><DATATYPE-DEFINITION-XHTML-REF>'+at[j].dataType+'</DATATYPE-DEFINITION-XHTML-REF></TYPE>' +
									'</ATTRIBUTE-DEFINITION-XHTML>'
							break;
						case 'ENUMERATION':
							// the property 'multiValued' in case of enumerated types must be specified in any case, because the ReqIF Server (like ReqIF) requires it. 
							// The property 'dataType.multiple' is invisible for the server. 
							xml += 	'<ATTRIBUTE-DEFINITION-ENUMERATION IDENTIFIER="'+at[j].id+'" LONG-NAME="'+vocabulary.property.reqif(at[j].longName)+'" MULTI-VALUED="'+multipleChoice(at[j],pr)+'" LAST-CHANGE="'+dateTime(at[j])+'">' +
										'<TYPE><DATATYPE-DEFINITION-ENUMERATION-REF>'+at[j].dataType+'</DATATYPE-DEFINITION-ENUMERATION-REF></TYPE>' +
									'</ATTRIBUTE-DEFINITION-ENUMERATION>'
							break;
						case 'DATETIME':
							xml += 	'<ATTRIBUTE-DEFINITION-DATE IDENTIFIER="'+at[j].id+'" LONG-NAME="'+vocabulary.property.reqif(at[j].longName)+'" LAST-CHANGE="'+dateTime(at[j])+'">' +
										'<TYPE><DATATYPE-DEFINITION-DATE-REF>'+at[j].dataType+'</DATATYPE-DEFINITION-DATE-REF></TYPE>' +
									'</ATTRIBUTE-DEFINITION-DATE>'
							break;
					}
				};
				return xml + '</SPEC-ATTRIBUTES>'
			}
	};

/*	self.toServer = function( mode, data ) {
		// store SpecIF data in the server:

		if( data ) self.value = data;
//		console.debug('toServer', self.value.id);

		var sDO = $.Deferred();
		switch( mode ) {
			case 'update':
				// Load the project with the types for comparison:
//				console.debug('update', self.value.id);
				myProject.read({id:self.value.id}, true)	// true: reload from server
					.done( function() {
						// now start to save the new or updated elements:
						myProject.update( specif.put(), 'extend' )
							.progress( sDO.notify )
							.done( sDO.resolve )
							.fail( sDO.reject );
						self.init()			// delete the transient data
					})
					.fail( sDO.reject );
				break;
			default:
				// Upload the project to the server:
				myProject.create( specif.put() )
					.progress( sDO.notify )
					.done( sDO.resolve )
					.fail( sDO.reject );
				self.init()			// delete the transient data
		};
		return sDO
	}
*/	
	function pTypeById(sT,id) {
		// given an attribute type ID, return it's own object:
		for( var t=sT.length-1;t>-1;t-- ) {
			if( !sT[t][names.pClasses] ) continue;
			for( var a=sT[t][names.pClasses].length-1;a>-1;a-- ) {
				if( id==sT[t][names.pClasses][a].id ) return sT[t][names.pClasses][a]
			}
		};
		return null
	}
	function anyPropTypeById( id ) {
		// find the type having the attributeType with the given attributeId.
		// Can be an attributeType of any of the three types:
		return pTypeById( self.value[names.rClasses], id )
			|| pTypeById( self.value[names.hClasses], id )
			|| pTypeById( self.value[names.sClasses], id )
	}
	
	return self
};

//////////////////////////
// global helper functions:
function dataTypeOf( dTs, sT, aTid ) {
	// given an attributeType ID, return it's dataType:
	return itemById( dTs, itemById( sT.attributeTypes, aTid ).dataType )
	//                    get attributeType
	//	   get dataType
}
function enumValStr( dT, attr ) {
	// for an attribute value of type ENUMERATION, create a comma-separated-value string of titles;
	// for all others, return the content as is:
	if( dT.type!='ENUMERATION' ) return attr.content;
	let ct = '',
		val = null,
		st = attr.longName==CONFIG.stereotype,
		vL = attr.content.split(',');  // in case of ENUMERATION, content carries comma-separated value-IDs
	for( var v=0,V=vL.length;v<V;v++ ) {
		val = itemById(dT.values,vL[v].trim());
		// If 'val' is an id, replace it by title, otherwise don't change:
		// For example, when an object is from a search hitlist or from a revision list, 
		// the value ids of an ENUMERATION have already been replaced by the corresponding titles.
		// Add 'double-angle quotation' in case of stereotype values.
		if( val ) ct += (v==0?'':', ')+(st?('&#x00ab;'+val.title+'&#x00bb;'):val.title)
		else ct += (v==0?'':', ')+vL[v]
	};
	return ct
}
function multipleChoice( attrT, pr ) {
	pr = pr || myProject;
	// return 'true', if either the attribute type specifies it, or by default its datatype;
	// if defined, the attribute type's value supersedes the datatype's value:
//	return (attrT.multiple || (attrT.multiple==undefined && itemById(pr.dataTypes,attrT.dataType).multiple))?true:false
	return attrT.multiple || (typeof attrT.multiple!='boolean' && itemById(pr.dataTypes,attrT.dataType).multiple)
	// Note: specif-check applies the same logic in function 'checkpropValues(..)'
}
function titleIdx( aL ) {
	// Find the index of the attribute to be used as title.
	// The result depends on the current user - only the attributes with read permission are taken into consideration
		
/*	// Note that the logic has been simplified.
	// Up until revision 0.92.34, the title attribute which was listed first in CONFIG.XXAttributes was chosen.
		var idx = -1;
		for( var c=0, C=CONFIG.headingAttributes.length; c<C; c++) {  // iterate configuration list; leading entry has priority
			idx = indexByName( aL, CONFIG.headingAttributes[c] );
			if( idx>-1 ) return idx
		};
	// Now, the first attribute which is found in the respective list is chosen.
	// ToDo: Check, if the results differ in practice ...
*/	
	for( var a=0,A=aL.length;a<A;a++ ) {
		// First, check the configured headings:
		if( CONFIG.headingAttributes.indexOf( aL[a].longName )>-1 ) return a;
		// If nothing has been found, check the configured titles:
		if( CONFIG.titleAttributes.indexOf( aL[a].longName )>-1 ) return a
	};
	return -1
}
function titleOf( item ) {
	// look for a translation, first:
	return i18n.lookup( item.longName ) || item.id
}
function titleFromAttributes( aL ) {
	// get the title from the attributes:
	if( aL && aL.length>0 ) {
		// 1. look for an attribute serving as title:
		let ti = titleIdx( aL );
		if( ti>-1 ) {  // found!
			// Remove all formatting for the title, as the app's format shall prevail.
			// Before, remove all marked deletions (as prepared be diffmatchpatch).
			// ToDo: Check, whether this is at all called in a context where deletions and insertions are marked ..
			return aL[ti].content.replace(/<del[^<]+<\/del>/g,'').stripHTML().trim()
		};
		// 2. otherwise, find a description and take the beginning:
		// find a description and take the beginning:
		for( var a=0,A=aL.length;a<A;a++ ) {
			if( CONFIG.descriptionAttributes.indexOf( aL[a].longName )>-1 ) 
				return aL[a].content.stripHTML().truncate( CONFIG.maxTitleLength )
		}
	};
	return ''
}
function objTitleOf( ob ) {
	// get the title from the attributes or a replacement value in case of default:
	return ob.title || titleFromAttributes( ob.attributes ) || titleOf( ob )
}
function instanceTitleWithIcon( el ) {
	// add an icon to an instance's title;
	// works for objects, relations, hierarchies and also the unspecified RIF instances.
	// The icon is defined in the instances's type:
	return CONFIG.addIconToInstance?objTitleOf(el).addIcon( itemById( myProject.specTypes, el.specType ).icon ):objTitleOf(el)
}
/*	function typeTitleWithIcon( t ) {
	// add the icon to a type's title, if defined:
	return (CONFIG.addIconToType?titleOf(t).addIcon( t.icon ):titleOf(t))
}*/
function hasContent( pV ) {
	return pV.stripHTML().trim().length>0
		|| /<object[^>]+(\/>|>[\s\S]*?<\/object>)/.test(pV)
		|| /<img[^>]+(\/>|>[\s\S]*?<\/img>)/.test(pV)
}
function initAttr( aT ) {
	// create an empty attribute from the supplied attributeType:
	var att = {
		longName: aT.longName,
		attributeType: aT.id,
//		dataType: aT.dataType, 
		upd: aT.upd,
		del: aT.del
	};
	switch( itemById( myProject.dataTypes, aT.dataType ).type ) {
/*		case 'XHTML':
			att.content = '<div>\n</div>';
			break;
*/		case 'ENUMERATION':
			att.valueIDs = [];	// needed for editing
		default:
			att.content = ''
	};
	return att
}
function initAttrR( aT ) {
	return aT.rea?initAttr( aT ):null
}
function initAttrC( aT ) {
	return aT.cre?initAttr( aT ):null
}
function classifyAttributes( el ) {
	"use strict";
	// add missing (empty) attributes and
	// classify attributes into title, descriptions and otherAttributes;
	// for objects, relations and hierarchies/specifications.
	var cP = {
		title: null,
		specType: itemById( myProject.specTypes, el.specType),
		revision: el.revision,
		descriptions: []
	};
	// create a new list by copying the elements (do not copy the list ;-):
	cP.otherAttributes = normalizeAtts( cP.specType.attributeTypes, el.attributes );

	// Now, all attributes are listed in otherAttributes;
	// in the following, the attributes used as title or description will be identified
	// and removed from otherAttributes.

	// a) Find and set the configured title:
	let a = titleIdx( cP.otherAttributes );
	if( a>-1 ) {  // found!
		// Remove all formatting for the title, as the app's format shall prevail.
		// Before, remove all marked deletions (as prepared be diffmatchpatch).
		cP.title = deformat( cP.otherAttributes[a].content );
		// remove title from otherAttributes:
		cP.otherAttributes.splice(a,1) 
//	} else {
		// In certain cases (RIF export or comment), there is no title attribute/property. 
		// Then some other value will be taken to set the longName when posting the object/resource to the server, 
		// so that the hierarchy gets a title: see objTitleOf().
		// But here we want only 'real' titles and none, if there is none.
		// So we do NOT say, for example:
//		cP.title = titleOf( el )
	};
		
	// b) Check the configured descriptions:
	// We must iterate backwards, because we alter the list of otherAttributes.
	for( a=cP.otherAttributes.length-1;a>-1;a--) {
		if( CONFIG.descriptionAttributes.indexOf( cP.otherAttributes[a].longName )>-1 ) {
			// To keep the original order of the attributes, the unshift() method is used.
//			cP.descriptions.unshift( cP.otherAttributes.splice(a,1)[0] )
			cP.descriptions.unshift( cP.otherAttributes[a] );
			cP.otherAttributes.splice(a,1) 
		}
	};
//	console.debug( 'classifyAttributes', cP.title, cP.descriptions, cP.otherAttributes );
	return cP

	function deformat( txt ) {
		// Remove all HTML-tags from 'txt',
		// but keep all marked deletions and insertions (as prepared be diffmatchpatch):
		// ToDo: consider to use this function only in the context of showing revisions and filter results,
		// 		 ... and to use a similar implementation which does not save the deletions and insertions, otherwise.
		let mL = [], dL = [], iL = [];
		txt = txt.replace(/<del[^<]+<\/del>/g, function($0) {
										dL.push($0);
										return 'hoKupokus'+(dL.length-1)+'#'
									});
		txt = txt.replace(/<ins[^<]+<\/ins>/g, function($0) {
										iL.push($0);
										return 'siMalabim'+(iL.length-1)+'#'
									});
		txt = txt.replace(/<mark[^<]+<\/mark>/g, function($0) {
										mL.push($0);
										return 'abRakad@bra'+(mL.length-1)+'#'
									});
		// Remove all formatting for the title, as the app's format shall prevail:
		txt = txt.stripHTML().trim();
		// Finally re-insert the deletions and insertions with their tags:
		// ToDo: Remove any HTML-tags within insertions and deletions
		if(mL.length) txt = txt.replace( /abRakad@bra([0-9]+)#/g, function( $0, $1 ) { return mL[$1] });
		if(iL.length) txt = txt.replace( /siMalabim([0-9]+)#/g, function( $0, $1 ) { return iL[$1] });
		if(dL.length) txt = txt.replace( /hoKupokus([0-9]+)#/g, function( $0, $1 ) { return dL[$1] });
		return txt
	}
}
function normalizeAtts( tL, oL ) { // attributeType list, original attribute list
	// Create a list of attributes in the sequence of attributeTypes of the respective specType.
	// Use those provided by the original list (oL) and fill in missing ones with default (no) values.

	let a,A,p,nL=[];  
	for( a=0,A=tL.length;a<A;a++ ) {
		p = itemBy( oL, 'attributeType', tL[a].id )
			|| initAttrR(tL[a]);
		if( p ) nL.push( p )
	};
	return nL // normalized attribute list
}
function get(url,rspT,auth,successFn,nextFn) {
	// https://blog.garstasio.com/you-dont-need-jquery/
	// https://www.sitepoint.com/guide-vanilla-ajax-without-jquery/
	var xhr = new XMLHttpRequest();
	xhr.open('GET', url, true);
	if( auth ) xhr.withCredentials = "true";
	// https://stackoverflow.com/a/42916772/2214
	xhr.responseType = rspT;
	xhr.onreadystatechange = function () {
//		console.debug('xhr',this.readyState,this)
		if (this.readyState<4 ) return;
		if (this.readyState==4 && this.status==200) {
			if( typeof successFn=="function" ) successFn(this)
		};
		// continue in case of success and error:
		if( typeof nextFn=="function" ) nextFn()	
	};
	xhr.send(null)
}

var fileRef = {
/*	All sample data (except ProSTEP) taken from a JSON response of the ReqIF Server.

	Attention: The html-sanitizing in the xhtml-Editor (SCEditor) 
	- removes objects, which have only properties and do not have a content:
		<object data=\"path/filename.ext\" type=\"...\">
			<object data=\"path/filename.ext\" type=\"..\">Content</object>
		</object>	
	- renames any 'name'-property in objects to an 'id'-property
*/
	fromServer: function( txt, opts ) {
		if( opts ) {
			if( opts.projId==undefined ) opts.projId = myProject.id;
			if( opts.rev==undefined ) opts.rev = 0;
			if( opts.clickableElements==undefined ) opts.clickableElements = false
		} else {
			var opts = {
				projId: myProject.id,
				rev: 0,
				clickableElements: false
			}
		};
		
/*			function addFilePath( u ) {
				if( /^https?:\/\/|^mailto:/i.test( u ) ) {
					// don't change an external link starting with 'http://', 'https://' or 'mailto:'
//					console.debug('addFilePath no change',u);
					return u  		
				};
				// else, add relative path:
//				console.debug('addFilepath', u );
//				console.debug('addFilepath',itemById( myProject.files, u ));
				return URL.createObjectURL( itemById( myProject.files, u ).blob )
			}
*/			function getType( str ) {
				var t = /(type="[^"]+")/.exec( str );
				if( t==null ) return '';
				return (' '+t[1])
			}
			function getStyle( str ) {
				var s = /(style="[^"]+")/.exec( str );
				if( s==null ) return '';  
				return (' '+s[1])
			}
			function getUrl( str ) {
				// get the URL:
				var l = /(href|data)="([^"]+)"/.exec( str );  // url in l[2]
				// return null, because an URL is expected in any case:
				if( l == null ) { return null };    
				return l[2].replace('\\','/')
			}

		// Prepare a file reference for viewing and editing:
//		console.debug('fromServer 0: ', txt);
		var repSts = [];   // a temporary store for replacement strings
			
		// 1. transform two nested objects to link+object resp. link+image:
//		txt = txt.replace( /<object([^>]+)>[\s\S]*?<object([^>]+)(\/>|>([\s\S]*?)<\/object>)[^>]*<\/object>/g,   
		txt = txt.replace( RE.tagNestedObjects,   
			function( $0, $1, $2, $3, $4 ) {        // description is $4
				var u1 = getUrl( $1 ),  			// the primary file
					t1 = getType( $1 ); 
				var u2 = getUrl( $2 ), 				// the preview image
					t2 = getType( $2 ), 
					s2 = getStyle( $2 ); 

				// If there is no description, use the name of the link target:
				if( !$4 ) {
					$4 = u1   // $4 is now the description between object tags
				};
//				console.debug('fileRef.fromServer 1 found: ', $0, $4, u1, t1, u2, t2 );
//				u1 = addFilePath(u1);
//				u2 = addFilePath(u2);
				if( !u2 ) console.info('no image found');

				// all of the following work to a certain extent:
				//   <a></a> for downloading the OLE, 
				//   <object>text</object> allows to obtain the text as part of content after HTMLstrip (e.g. in search of a somewhat meaningful title)
				//   Note that IE displays the object tag only in case of SVG and PNG; the latter is used with DOORS OLE-Objects.

/*				if( opts.clickableElements )
					repSts.push( '<div class="forImage"><a href="'+u1+'"'+t1+' ><object data="'+u2+'"'+t2+s2+' >'+$4+'</object></a></div>' )
				else
					repSts.push( '<div class="forImage"><a href="'+u1+'"'+t1+' ><img src="'+u2+'"'+t2+s2+' alt="'+$4+'" /></a></div>' );
				// avoid that a pattern is processed twice: insert a placeholder and replace it with the prepared string at the end ...

				repSts.push( '<div class="forImage"><a href="'+u1+'"'+t1+' ><img src="'+u2+'"'+t2+s2+' alt="'+$4+'" /></a></div>' );  // works.
*/ 
				let f = itemById(myProject.files,u2);
				if( f ) {
					repSts.push( '<div id="'+u2.simpleHash()+'" class="forImage"></div>' );
					showImg( f );
					return 'aBrakadabra'+(repSts.length-1)+''
				} else {
					return '<div class="notice-danger" >Image missing: '+u2+'</div>'
				}
			}
		);
//		console.debug('fileRef.fromServer 1: ', txt);
			
		// 2. transform a single object to link+object resp. link+image:
//		txt = txt.replace( /<object([^>]+)(\/>|>[^<]*<\/object>)/g,   //  comprehensive tag or tag pair
		txt = txt.replace( RE.tagSingleObject,   //  comprehensive tag or tag pair
			function( $0, $1, $2, $3 ){ 
//				var pairedImgExists = function( url ) {
//					// ToDo: check actually ...
//					return true
//				};

				let u1 = getUrl( $1 ), 
					t1 = getType( $1 ), 
					s1 = getStyle( $1 );

				let e = u1.fileExt();
				if( e==null ) return $0;

				// $3 is the description between the tags <object></object>:
				let d = $3 || u1,
					hasImg = true;
				e = e.toLowerCase();
//				console.debug( $0, 'url: ', u1, 'ext: ', e, 'name: ',d );
//				u1 = addFilePath(u1);
				if( !u1 ) console.info('no image found');
					
				if( CONFIG.imgExtensions.indexOf( e )>-1 ) {  
					// it is an image, show it:
/*					if( opts.clickableElements && ( !browser.isIE || ( e=='svg' || e=='png' ) && browser.displaysObjects ) ) {  
						// For Firefox, Chrome. And for IE10+, if and only if the object is PNG or SVG.
						// Only an <object ..> allows for clicking on svg diagram elements with embedded links:
						d = '<object data="'+u1+'"'+t1+s1+' >'+d+'</object>'
					} else {
						// IE only displays images of type SVG and PNG with an <object> tag, so the others will be rendered with an <img> tag.
						// In case of IE9 prohibit that svg diagram elements can be clicked.
						//   For the time being, the click is handled via URL with hash parameters and with IE9 there is no chance to modify the browser history (=URL).
						//   As soon as the clicks are handled internally, also a clickable svg (via <object ..> can be presented to IE9, as well.
						d = '<img src="'+u1+'"'+t1+s1+' alt="'+d+'" />'
					}
*/				
					let f = itemById(myProject.files,u1);
//					console.debug('f',f);
					if( f ) {
						d = '<div id="'+u1.simpleHash()+'" class="forImage"></div>';
						showImg( f );
					} else {
						hasImg = false;
						d = '<div class="notice-danger" >Image missing: '+d+'</div>'
					}
/*				} else {
					if( CONFIG.officeExtensions.indexOf( e )>-1 ) {  
						// it is an office file, show an icon plus filename:
						d = '<img src="'+CONFIG.imgURL+'/'+e+'-icon.png" type="image/png" alt="'+d+'" />'
					} else {
						if( e=='ole' ) {  
							// It is an ole-file, so add a preview image;
							// in case there is no preview image, the browser will display d holding the description
							// IE: works, if preview is PNG, but a JPG is not displayed (perhaps because of wrong type ...)
							// 		But in case of IE it appears that even with correct type a JPG is not shown by an <object> tag
							// ToDo: Check if there *is* a preview image and which type it has, use an <img> tag.
//							d = '<object data="'+u1.fileName()+'.png" type="image/png" >'+d+'</object>'
							d = '<img src="'+u1.fileName()+'.png" type="image/png" alt="'+d+'" />'
						} else {
							// last resort is to take the filename:
							hasImg = false;
							d = '<span>'+d+'</span>'  
//						}
					}
*/				};
					
				// finally add the link and an enclosing div for the formatting:
//				return ('<div class="forImage"><a href="'+u1+'"'+t1+' >'+d+'</a></div>')

				// avoid that a pattern is processed twice.
				// insert a placeholder and replace it with the prepared string at the end ...
				if( hasImg )
//					repSts.push( '<div class="forImage"><a href="'+u1+'"'+t1+' >'+d+'</a></div>' )
					repSts.push( d )
				else
					repSts.push( '<a href="'+u1+'"'+t1+' >'+d+'</a>' );
				
				return 'aBrakadabra'+(repSts.length-1)+''
			}
		);	
//		console.debug('fileRef.fromServer 2: ', txt);
				
		// 3. process a single link:
		// add an icon to known office files.
		txt = txt.replace( RE.tagA,  
			function( $0, $1, $2 ){ 
				var u1 = getUrl( $1 ),
					e = u1.fileExt();
//				console.debug( $1, $2, u1, e );
				if( e==null ) return $0     // no change, if no extension found
//				if( /(<object|<img)/g.test( $2 ) ) return $0;		// no change, if an embedded object or image
				if( CONFIG.officeExtensions.indexOf( e.toLowerCase() )<0 ) return $0;	// no change, if not an office file

				var t1 = getType( $1 ); 
				if( !$2 ) {
					var d = u1.split('/');  // the last element is a filename with extension
					$2 = d[d.length-1]   // $2 is now the filename with extension
				};
//				u1 = addFilePath(u1);

				// it is an office file, add an icon:
				e = '<img src="'+CONFIG.imgURL+'/'+e+'-icon.png" type="image/png" />'
					
				// finally add the link and an enclosing div for the formatting:
				return ('<div class="forImage"><a href="'+u1+'"'+t1+' >'+e+'</a></div>')
			}
		);	
//		console.debug('fileRef.fromServer 3: ', txt);

		// Now, at the end, replace the placeholders with the respective strings,
		txt = txt.replace( /aBrakadabra([0-9]+)/g,  
			function( $0, $1 ) { 
				return repSts[$1]
			});
//		console.debug('fileRef.fromServer result: ', txt);
		return txt
	},
	// prepare a file reference to be compatible with ReqIF spec and conventions:
	toServer: function( txt ) {
			function getType( str ) {
				var t = /(type="[^"]+")/.exec( str );
				if( t==null ) return '';
				return (' '+t[1])
			}
			function getStyle( str ) {
				var s = /(style="[^"]+")/.exec( str );
				if( s==null ) return '';  
				return (' '+s[1])
			}
			function getUrl( str, prp ) {
				// get the URL:
				var l = new RegExp(prp+'="([^"]+)"','').exec( str );
				// return null, because an URL is expected in any case:
				if( l==null ) return null;    

				// ToDo: More greediness!?
				var loc = /[^"]*\/projects\/[^"]*\/files\/([^"]+)/i.exec( l[1] );    // ...projects/.../files/..
				// If matching, it is a local path, otherwise an external:
				// ToDo: Another ReqIF Server instance is not recognized as an external link. Remove that limitation.
				// ToDo: If the path is pointing to a specific revision of a file, the revision is ignored/removed.
				if( loc == null ) return l[1];  		// external link: keep full path
				return loc[1]              				// local link: take path following '.../files/'
			};
//		console.debug('toServer 0: ', JSON.stringify(txt));

		// Remove the div which has been added for formatting:
		// ToDo: This does not work in all cases. Observed with <a>..<object ...>text</object></a> used with an OLE object.
		txt = txt.replace( /<div class="forImage">([\s\S]+?<\/a>)[\s]*<\/div>/g,  // note the 'lazy plus' !
			function( $0, $1 ){ return $1 }
		);	
//		console.debug('toServer 1: ', JSON.stringify(txt));

		// 1. In case of two nested objects, make the URLs relative to the project
		//    The inner object can be a tag pair <object .. >....</object> or comprehensive tag <object .. />.
		txt = txt.replace( /<object([^>]+)>[\s\S]*?<object([^>]+)(\/>|>([\s\S]*?)<\/object>)[^>]*<\/object>/g,  // description is $4 
			function( $0, $1, $2, $3, $4 ) { 
				var u1 = getUrl( $1, 'data' ),  			// the primary information
					t1 = getType( $1 ); 
				var u2 = getUrl( $2, 'data' ), 
					t2 = getType( $2 ), 
					s2 = getStyle( $2 ); 

				// If there is no description, use the name of the link target:
				if( !$4 ) $4 = u1;   // $4 is now the description between object tags
				
				return '<object data="'+u1+'"'+t1+' ><object data="'+u2+'"'+t2+s2+' />'+$4+'</object>'
			}
		);	
//		console.debug('toServer 2: ', JSON.stringify(txt));
			
		// 2. Transform link and image to nested XHTML object(s) or a single XHTML object:
		//    (Img is not allowed in RIF/ReqIF and it is proposed by the ReqIF Implementor Forum to use nested objects)
		txt = txt.replace( /<a([^>]+)>[^<]*<img([^>]+)(\/>|>[^<]*<\/img>)([^<]*)<\/a>/g,  
			function( $0, $1, $2, $3, $4 ) { 
				var u1 = getUrl( $1, 'href' );  			// the primary information
				if( u1==null ) return '';					// suppress it, if incomplete
				var t1 = getType( $1 ); 					

				var u2 = getUrl( $2, 'src' ); 				// the image
				if( u2==null ) return '';					// suppress it, if incomplete
				var t2 = getType( $2 );						
				var s2 = getStyle( $2 );

				// If there is no description, use the name of the link target:
				if( !$4 ) $4 = u1;   // $4 is now the filename with extension
					
				if( u1==u2 )   
					// Create a single object, if targets of link and image are equal:
					return ('<object data="'+u2+'"'+t2+s2+' >'+$4+'</object>');
						
				if( /\.\/im[^-]+-icon\.png/i.test( u2 ) )  // self-supplied icons: "./im*-icon.png"
					// Create a single object, if the image is a locally provided icon:
					// It is assumed that the self-supplied icons are found in a folder starting with '/im' (for 'img' or 'image')
					// ... and that the path does not contain any dash '-'.
					return ('<object data="'+u1+'"'+t1+' >'+$4+'</object>');
						
				// If targets of link and image are different, create a nested pair of objects to keep the preview.
				return '<object data="'+u1+'"'+t1+' ><object data="'+u2+'"'+t2+s2+' >'+$4+'</object></object>'
			}
		);
//		console.debug('toServer 3: ', JSON.stringify(txt));

		// 3. Transform a link plus object (in case of svg) to nested XHTML object(s):
		txt = txt.replace( /<a([^>]+)>[^<]*<object([^>]+)(\/>|>([\s\S]*?)<\/object>)[^<]*<\/a>/g,  
			function( $0, $1, $2, $3, $4 ) { 
				// parse the primary information:
				var u1 = getUrl( $1, 'href' ); 				
				if( u1==null ) return ''
				var t1 = getType( $1 ); 					

				// Parse the image information: 
				var u2 = getUrl( $2, 'data' ); 				
				if( u2==null ) return ''
				var t2 = getType( $2 );
				var s2 = getStyle( $2 );
					
				// If there is no description, use the name of the link target:
				if( !$4 ) $4 = u2;   // $4 is now the filename with extension
					
				if( u1==u2 ) {
					// If targets of link and image are equal or the image is locally provided icon, create a single object.
					// Any locally provided icon is removed; it will be added again when reading.
					return ('<object data="'+u2+'"'+t2+s2+' >'+$4+'</object>')
				} else {
					// If targets of link and image are different, create a nested pair of objects to keep the preview.
					return '<object data="'+u1+'"'+t1+' ><object data="'+u2+'"'+t2+s2+' >'+$4+'</object></object>'
				}
			}
		);
//		console.debug('toServer 4: ', JSON.stringify(txt));

		// 4. If there is just an image, create a single object, because <img..> is not allowed in ReqIF:
		// This has been created interactively by a user, most probably without mime-type
		txt = txt.replace( /<img([^>]+)[\/]{0,1}>/g,
			function( $0, $1 ){
				var u = getUrl( $1, 'src' );
				if( u==null ) return ''
				var t = getType( $1 );
				var s = getStyle( $1 );

				if( t=='' ) {
					// Derive mime-type from file extension.
					// It is essential for SVG, otherwise the formatting in IE will not be correct.
					var e = u.fileExt();
					if( e ) {
						let ei = CONFIG.imgExtensions.indexOf( e.toLowerCase() ); 
						if( ei>-1 ) {t = ' type="'+CONFIG.imgTypes[ei]+'"'}
					}
				};
				return ('<object data="'+u+'"'+t+s+' >'+u+'</object>');  
			} 
		);
//		console.debug('toServer 5:', JSON.stringify(txt));

		// 5. If there is just a link, make the URLs relative to the project:
		txt = txt.replace( /<a([^>]+)(\/>|>([^>]+)<\/a>)/g,
			function( $0, $1, $2, $3 ){
				var u = getUrl( $1, 'href' );
				if( u==null ) return ''

				// If there is no description, use the name of the link target:
				if( !$3 ) $3 = u;   

				return ('<a href="'+u+'" >'+$3+'</a>');  
			} 
		);
//		console.debug('toServer result:', JSON.stringify(txt));

		return txt
	}
};
function showImg(img) {
		function showSvg(f,t) {
			if( !f ) 
				return;
			if( !f.blob ) {
				// ToDo: in case of ReqIF Server, the blob itself must be fetched first (the file list just has meta-data)
				document.getElementById(f.id.simpleHash()).innerHTML = '<div class="notice-danger" >Image missing: '+(f.title||f.id)+'</div>';
				return
			};
			
			// ToDo: Load images embedded in SVG
			const reader = new FileReader();
			reader.addEventListener('loadend', function(e) {
		//		console.debug('showSvg',e);
				document.getElementById(f.id.simpleHash()).innerHTML = e.target.result
			});
			if( typeof t == 'number' && t>0 )
				setTimeout(function() {
		//			console.debug('showSvg',t);
					reader.readAsText(f.blob)
				}, t )
			else
				reader.readAsText(f.blob)
		}
		function showRaster(f,t) {
			if( !f ) 
				return;
			if( !f.blob ) {
				// ToDo: in case of ReqIF Server, the blob itself must be fetched first (the file list just has meta-data)
				document.getElementById(f.id.simpleHash()).innerHTML = '<div class="notice-danger" >Image missing: '+(f.title||f.id)+'</div>';
				return
			};
			
			const reader = new FileReader();
			reader.addEventListener('loadend', function(e) {
		//		console.debug('showImg',e);
		//		document.getElementById(f.id.simpleHash()).innerHTML = '<img src="'+e.target.result+'" type="'+f.type+'" />'
				document.getElementById(f.id.simpleHash()).innerHTML = '<img src="'+e.target.result+'" type="'+f.type+'" '+(f.title?'alt="'+f.title+'" ':'')+'/>'
			});
			if( typeof t == 'number' && t>0 )
				setTimeout(function() {
		//			console.debug('showImg',t);
					reader.readAsDataURL(f.blob)
				}, t )
			else
				reader.readAsDataURL(f.blob)
		}
	switch( img.type ) {
		case 'image/png':
		case 'image/x-png':
		case 'image/jpeg':
		case 'image/jpg':
		case 'image/gif':
			// reference the original list item, which has the blob and other attributes:
			showRaster(itemById( myProject.files, img.id ));
			break;
		case 'image/svg+xml':
			showSvg(itemById( myProject.files, img.id ))
	}
}
